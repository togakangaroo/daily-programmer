I am looking for a job now and my last six months have been more devops focused. Let's get back into some coding

For this I just asked Mistral to cook me up a simple problem, here's what it gave me

* Problem Statement

In a magic square, all of the numbers from =1= to =n^2= appear, and the sums of the numbers in any row, column, or diagonal are always equal. Given an integer ~n (1 <= n <= 9)~, write a function that creates an
and returns such a magic square for the given size.

Here is an example of a =3x3= magic square:
#+begin_quote
[8, 1, 6]
[3, 5, 7]
[4, 9, 2]
#+end_quote


Create a function called =magicSquare= that takes in an integer =n= and returns a 2D list representing the magic square for the given size.

** Example:
#+begin_src python :eval no
magic_square(3) == [[8, 1, 6], [3, 5, 7], [4, 9, 2]]
#+end_src

** Constraints:
- The function should be able to handle any valid input from =1 to 9=.
- Use only basic data structures and built-in functions (avoid external libraries).


* Brainstorming
:PROPERTIES:
:header-args:python+: :eval no
:END:
A quick Google seems to indicate that magic squares are always possible, or at least possible enough that I think the constraints of the problem make sense. Sounds like there's "simple" techniques to do it. Maybe I'll look into those for a second implementation after I do this one.

I also want to use python because eh, it keeps coming up lately. I'll probably use elisp later.

Now what do we actually do? Well, a depth first search seems like the obvious thing, right?

In fact we know what the sum of every span (column, row, diagonal) in the square must be - it must be ~sum(1..n^2)/n~ which for a 3-quare would be ~45/3=15~. We could shortcut the DFS process by picking a number, then checking if that forces the sum of any spans to exceed it.

Additionally we *could* set a lower bound as well. If you are in a 3-square row that already contains a =1= then a =2= is out of the question since there would be no way to get to =15= with that. We could generalize it as a branch being a dead end if the row's current sum ~sum(span)~ plus the highest values possible in the remaining cells (~sum(n, n-1, n-2)~ ~n-len(span) times~) is less than our =Target= from above. This is good to know but feels more complicated thatn it might be worth within our constraints so lets punt on it.

Now, what sort of datastructure would be good here? What comes to mind is a 2d structure comprised of linked lists so that you can easily get the current spans as we go. Even though I'm picturing actually putting values into cells, it is probably best that this thing be immutable just because that works better for the detph first search, right? Lets write down the sort of operations we want to be able to do easily:

#+begin_src python
  new_square = set(square, row=0, column=2, value=7)
#+end_src
and the check for sums would be something like this

This seems like a good idea at first for an api
#+begin_src python
  if any((target_sum != sum(span) for span in get_spans(new_square, row=0, column=2))):
      return
#+end_src

but wait, that's not quite right, a span that isn't filled out yet isn't going to be the right sum but is not a dead end either. So I guess we could delegate the whole thing to the set function so it would be impossible to enter an invalid state. ~try_set~ instead of ~set~ and return ~True~ or ~False~ as to whether it succeeded. That would be easy enough to check so long as we have some sort of ~undefined~ token we could ignore (or coerce to 0 which works for the purposes of summing).

Finally I want to think about the structure. We really do need immutability I feel unless we want to be really invested in fastidiously cleaning up after each and every depth first search. Now normally I would say that some sort of copy-on-write implementation is what we want, but in this case we're simply storing integers. Copy-on-write would typically work by storing references to the "immutable" bits but that would just be references which aren't any smaller on the stack than integers are, right? I'm sure there's stuff you can do to make improvements here but at such small =n= it just doesn't seem like such a big deal to copy all the numbers in our square on each ~try_set()~

---

Ok, so that's one approach, lets just do a simple version of it. In fact, lets use my favorite approach of picturing ourselves physically on the problem space

I picture standing on a square grid with a book of available numbers. I tear down the page for the first number and pin it to the square, I then move forward and pin the next and I do this all the way across until I have pinned a number to each square. At that point I am done and I can check if it is a magic square. If it is, then hooray we did good; but, if not, then we must remove the last two notes and try things in a different order. Of course we know that this won't work but we can optimize in a bit. By repeating this process we will have successfully brute forced a solution.

Ok, but what about the optimization? Well it is important to understand that for a square of size =N=, each row, column, and diagonal must sum to

$$ \frac{N^2(N^2+1)}{2N} $$ which can be simplified as $$ \frac{N(N^2+1)}{2} $$ and represented as =T=

If we ever hit the following conditions then we can stop exploring as it is impossible to get a magic square from that state

- a row, column, or diagonal with a ~sum > T~
- a completed row, column, or diagonal with a ~sum != T~

Furthermore, if we can assume move top left to bottom right, if a completed row does not ~sum == T~ then no variation of that row will work. You could say the same thing of the ~/~ diagonal and columns as well, but under this assumption you wouldn't complete any of these until the last row so it doesn't save you on all that much iterations.

Also, you know what? I want to push myself a bit, I have only passing experience with Pandas, and I know it implements copy-on-write semantics for =DataFrame= so - even though it might not be the most efficient, lets learn something and do this with pandas


* Python Solution
:PROPERTIES:
:header-args:python+: :results silent
:header-args:python+: :tangle  (org-entry-get (point) "tangle-target" 't)
:END:

** Naive Attempt 1
:PROPERTIES:
:header-args:python+: :session magic-square-generation
:tangle-target: naive-attempt/magic_square_generation.py
:header-args:python+: :mkdirp 't
:END:
First some types and imports
#+begin_src python
  import pandas as pd
  import numpy as np
  from typing import Iterable
  from dataclasses import dataclass, field

  MagicSquareCells = pd.DataFrame

  @dataclass(frozen=True)
  class Position:
      row: int
      column: int
#+end_src

lets also build out a class for our magic square builder with some helper values set. Note that it's a ~Builder~ not a ~MagicSquare~ since we don't want it to be possible to create invalid objects (ie a magic square that is not actually magic)
#+begin_src python
  @dataclass(frozen=True)
  class MagicSquareBuilder:
      cells: MagicSquareCells
      side_size: int = field(init=False)
      max_span_sum: int = field(init=False)

      def __post_init__(self):
          object.__setattr__(self, 'side_size', self.cells.shape[0])
          # Using Godel's(?) equation for summing up sequential sequences / square_size
          object.__setattr__(self, 'max_span_sum', self.side_size*(1+self.side_size**2)/2)
#+end_src

We need a way to tell if a completed square is indeed magic, and that's going to be a bunch of our pandas stuff. I could make this stuff into methods on the class, but really its all in one module and typed so I see little point to it for the purposes of this exercise.

#+begin_src python
  def is_magic_square(square: MagicSquareBuilder) -> bool:
      row_sums = square.cells.sum(axis=1)
      first_row_sum = row_sums.iloc[0]
      all_rows_equal = (row_sums == first_row_sum).all()
      if not all_rows_equal:
          return False
      col_sums = square.cells.sum(axis=0)
      all_cols_sum_same_as_rows = (col_sums == first_row_sum).all()
      if not all_cols_sum_same_as_rows:
          return False
      return first_row_sum == np.diag(square.cells.values).sum() == np.diag(np.fliplr(square.cells.values)).sum()
#+end_src
#+begin_src python :results output pp replace :tangle no
  print(is_magic_square(MagicSquareBuilder(cells=pd.DataFrame([[1,2],[3,4]])))) # should be false
  magic_square = MagicSquareBuilder(cells=pd.DataFrame([
      [8, 1, 6],
      [3, 5, 7],
      [4, 9, 2],
  ]) )
  print(is_magic_square(magic_square))# should be true
#+end_src

#+RESULTS:
: False
: True

Ok, that works well. Now we need a way of setting a new value in our builder. A ~try_set~ function will allow us to run some basic checks before setting a value into a new copy of the builder. We want to make sure we're creating new instances since otherwise we'd have to clean up when unwinding the stack. I also believe that pandas might have some optimization around copying that can serve us well. At the very least, I see an article discussing that in Pandas 3.0 (which I'm not on yet).

**Assumption**: Here we are counting on the assumption that movement is top left to bottom right and that any filled values are filled with =0=

#+begin_src python
  def _potential_span_sums(square: MagicSquareBuilder, position: Position) -> Iterable[int]:
      row, column = position
      yield square.cells.iloc[row, :].values.sum()
      yield square.cells.iloc[:, column].values.sum()

      # \ Diagonal (main diagonal)
      if row == column:
          yield np.diag(square.cells.values).sum()

      # / Diagonal (anti-diagonal)
      if row == square.side_size - column - 1:
          yield np.diag(np.fliplr(square.cells.values)).sum()

  def try_set(square: MagicSquareBuilder, position: Position, value: int) -> None | MagicSquareBuilder:
      """Return a new square with position set to the passed in value. This will
      do some basic checking to ensure that the returned square could potentially
      still be a magic square. If not it will return None.
      """

      span_sums = _potential_span_sums(square, position)
      if any((square.max_span_sum < (x + value)) for x in span_sums):
          return None

      new_cells = square.cells.copy()
      new_cells.iloc[*position] = value
      return MagicSquareBuilder(cells=new_cells)
#+end_src

Lets experiment with that one

#+begin_src python :results output pp replace :tangle no
  incomplete_square = MagicSquareBuilder(cells=pd.DataFrame(np.zeros((3, 3), dtype=int)))
  print(try_set(incomplete_square, (2, 1), 20)) #should be none
  print(try_set(incomplete_square, (0, 1), 1)) #should be fine
#+end_src

#+RESULTS:
: None
: MagicSquareBuilder(cells=   0  1  2
: 0  0  1  0
: 1  0  0  0
: 2  0  0  0, side_size=3, max_span_sum=15.0)


Ok, so now lets actually implement the depth first search where we move from position to position and try to set values, drilling down to the next level if setting succeeds

#+begin_src python
  remaining_recursions = 100000
  def fill_magic_square(square: None | MagicSquareBuilder, remaining_positions: list[Position], remaining_values_to_try: list[int]) -> None | MagicSquareBuilder:
      assert len(remaining_positions) == len(remaining_values_to_try)
      global remaining_recursions

      assert 0 < remaining_recursions
      remaining_recursions -= 1

      if not remaining_positions:
          return square if is_magic_square(square) else None

      position_to_set, *other_positions = remaining_positions

      for value in remaining_values_to_try:
          square_with_value = try_set(square, position_to_set, value)
          if not square_with_value:
              continue
          all_other_values_to_try = [v for v in remaining_values_to_try if v != value]
          filled_square_with_value = fill_magic_square(square_with_value, other_positions, all_other_values_to_try)
          if filled_square_with_value:
              return filled_square_with_value

      return None

  def find_magic_square(size: int) -> None | MagicSquareCells:
      # While prefilling with zeros is not technically correct and would in many situations be better
      # to use nan, when working specifically with magic squares it kind of doesn't matter and
      # prefilling with zeros is just more efficient
      square = MagicSquareBuilder(cells=pd.DataFrame(np.zeros((size, size), dtype=int)))
      positions = list((r, c) for r in range(size) for c in range(size))
      all_values = list(range(1, size**2+1))
      square = fill_magic_square(square, positions, all_values)
      return square and square.cells
#+end_src

Lets try it

#+begin_src python :results output pp replace :tangle no
  print(find_magic_square(2)) # should be None
  print(find_magic_square(3)) # sould be a square
#+end_src

#+RESULTS:
: None
:    0  1  2
: 0  2  7  6
: 1  9  5  1
: 2  4  3  8


Wahoo that works, its not the most efficient but it does work. Although I notice that it is taking forever and I hit timeouts even on values as low as 4

#+begin_src python
if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        find_magic_square(int(sys.argv[1]))
#+end_src

#+RESULTS:

#+begin_src shell :results verbose :var script_name=(org-entry-get (point) "tangle-target" 't)
  timeout 10s python $script_name 4 2>&1
  echo $?
#+end_src

#+RESULTS:
: 124

Ok, so what I did is just too damn slow even for our limited constraints. Perhaps we can try to speed it up. I'm not ready to blame this all on Pandas just yet

** Attempt 2 - Constraint Solver
:PROPERTIES:
:tangle-target: constraint-solver/magic_square_generation.py
:header-args+: :dir ./constraint-solver
:header-args:python+: :session magic-square-generation-constraint-solver
:header-args:python+: :mkdirp 't
:header-args:python+: :comments link
:header-args:emacs-lisp+: :results silent
:END:

*** Brainstorming
Lets change the model to one of constraints. Here the idea is that we can fill out rows one at a time

| 2 |   |   |

Well we clearly can answer the remaining set of possibilities: ~{(1,13),(3,10),(4,9),(5,8),(6,7)}~ where each pair can go in any order. This can even be cached.

Now lets say we get to

| 2 | 7 | 6 |
| 9 |   |   |

The possibilities for the row are ~{(1,5),(2,4)}~, and for the column are ~{(2,6),(3,5)}~, for the dialgonal are ~{(1,13),(3,10),(4,9),(5,8),(6,7)}~ and for the anti-diagonal are ~{(1,8),(2,7),(4,5)}~. We flatten these sets and take the intersection and only one possiblity remains =5=. #e can go further and subtract from this the set of already used numbers to narrow it down further

Lets try this again but run through it till we hit a dead end. Also for the sake of expediency lets start at a high number

| 10 |   |   |

The remaining possibilities are ~{(1,4),(2,3)}~ we don't have anything else to go off of so lets pick that first tuple and fill it out before moving on to the next row. If this doesn't work out we can try out the next later

| 10 | 1 | 4 |
|    |   |   |

The possibilities on the row are all the variants but on the column are once more  ~{(1,4),(2,3)}~ so the intersection is those four numbers flattened. Subtracting out the set of already used values we are left with a possibility of ~{(2,3)}~.

Not having anything else to go on, lets prefill things in that order but we *were* just at another decision point.

| 10 | 1 | 4 |
|  2 |   |   |
|  3 |   |   |

Now for the rest of row[1] the possible values are ~{(1,13),(3,10),(4,9),(5,8),(6,7)}~, the possible column values are ~{(2,12),(3,11),(4,10),(5,9),(6,8)}~, the possible diagonals are ~{(1,4),(2,3)}~ and anti-diagonals are ~{(1,10),(2,9),(3,8),(5,6)}~. Flatten the and intersect and you get ~{3}~. That's not enough values to fill the row so we've hit a dead end. Lets back it up to the previous decision point

| 10 | 1 | 4 |
|  3 |   |   |
|  2 |   |   |

Now for the rest of row[1] the possible values are ~{(1,11),(2,10),(4,8),(5,7)}~, the possible column values are ~{(2,12),(3,11),(4,10),(5,9),(6,8)}~, the possible diagonals are ~{(1,4),(2,3)}~ and anti-diagonals are ~{(1,10),(2,9),(3,8),(5,6)}~. Flatten the and intersect and you get ~{2}~. Once again, that's not enough values to fill the row so we've hit a dead end.

Lets try that again but without any pairwise thoughts

| 10 |   |   |

The remaining possibilities are ~{1,2,3,4}~ lets pick the first Decision point!

| 10 | 1 |   |

The reminaing possibilities are ~4~, there isn't really a decision here for a 3x3 but would be for more

| 10 | 1 | 4 |
|    |   |   |

rows are unconstrained, column is contstrained to ~{1,2,3,4}~ subtract out the already used to get ~{2,3}~ and pick the first at a decision point

| 10 | 1 | 4 |
|  2 |   |   |

the next value is now constrained by row to ~{1,3,4,5,6,7,8,9,10}~ and by column to ~{2,3,4,5,6,7,8,9,10}~ by diagonal to ~{1,2,3,4}~ and by anti-diagonal to ~{1,2,3,4,5,6,7,8,9,10}~. This gives us an intersection of ~{3,4}~ and when you subtract all the used ones you get ~{3}~. Dead end!

Rolling back to the previous decision point

| 10 | 1 | 4 |
|  3 |   |   |

the next value is now constrained by row to ~{1,2,4,5,6,7,8,9,10}~ and by column to ~{2,3,4,5,6,7,8,9,10}~ by diagonal to ~{1,2,3,4}~ and by anti-diagonal to ~{1,2,3,4,5,6,7,8,9,10}~. This gives us an intersection of ~{2,4}~ and when you subtract all the used ones you get ~{2}~. Dead end! Our previous decision point was all the way back on position 2

| 10 | 2 |   |


| 10 | 2 | 3 |
|    |   |   |

rows are unconstrained, column is contstrained to ~{1,2,3,4}~ subtract out the already used to get ~{1,4}~ and pick the first at a decision point

| 10 | 2 | 3 |
|  1 |   |   |

the next value is now constrained by row to ~{2,3,4,5,6,7,8,9,10}~ and by column to ~{1,3,4,5,6,7,8,9,10}~ by diagonal to ~{1,2,3,4}~ and by anti-diagonal to ~{1,2,4,5,6,7,8,9,10}~. This gives us an intersection of ~{2,4}~ and when you subtract all the used ones you get ~{4}~. Dead end!

At this point I am noticing that we're just reflecting the square from above. I guess once we eliminate a set of values for row 1 we could *also* eliminate them for column 1. This might be like overkill as an optimization for our needs though I'm sure it can halve some runtimes.

Ok, we'll do this one more time but on a ~N=4~, =4x4= square.

I'm also going to be really methodical here with making my steps explicit and listing all constraints. Some universal constraints that we will be applying are

**** Defining our Constraints
- Known Value :: Must be in \( [1, N^2] = [1,16] \)
- Row Sum :: Ensure the row sum is
    \( S = \frac{N(1+N^2)}{2} = 34 \)
  So when you're on row index =r= and the sum so far is =R=, the bounds will be \( [1, S-R ] \)
  Though we can actually decrease it further any *sum* of the range of cells after =r= must be possible. But the lowest possible sum for a number of cells =k= ...

  - When r=0 there are k=3 left after this one. \( R'=3+2+1=6 \)
  - When r=1 there's k=2 left. \( R'=2+1=3 \)
  - When r=2 there's k=1 left. \( R'=1 \)
  - When r=3 there's k=0 left. \( R'=0 \)
  In this case \( k=N-r-1 \). and \( R'=\frac{k(k+1)}{2} \)

  which we can subsitute in to get
  \begin{equation}
    \frac{(N-r-1)(N-r-1+1)}{2}
    \frac{(N-r-1)(N-r)}{2}
    \\=R'
  \end{equation}

  I think that's the neatest thing we could reduce it to? So we have this equation \( S = R + V[r] + R' \)

  And finally twe get

  \( [1, S-R-R'] \)

  which accounts for the fact that you don't want to sum up *all* the way to =S= before you get to the end.
  **Important Caveat*: If \( r+1=N \) then \( [S-R-R']=[S-R] \) is also the lowerbound
- Column Sum :: Ensure the same for column sum on column index =c= when the sum so far is =C=, the bounds will be \( [1, S-C-C'] \)
- Diagonal Sum :: When \( r=c \), the same for diagonal sum when the sum so far is =D=, the bounds will be \( [1, S-D-D'] \)
- Anti-Diagonal Sum :: When \( r=(N-c-1) \), the same for the anti-diagonal sum when the sum so far is =D_a=, the bounds will be \( [1, S-D_a-D_a'] \)
- Uniqueness :: Must not be one of the numbers already used
- Disallowed :: Values we already tried DFS when searching this decision point

**** 4 Square Sample

At each decision point we will pick the highest number possible. It shouldn't make a lot of difference but we can hopefully use it to cut down on some options.

We are going to move top left to bottom right, backtracking at each decision point as necessary.

| Cell | Row Sum | Column Sum | Diagonal Sum | Anti-diagonal | Uniqueness            | Disallowed | Decision |
|------+---------+------------+--------------+---------------+-----------------------+------------+----------|
| 0 0  | [1,34]  | [1,34]     | [1,34]       |               |                       |            |       16 |
| 0 1  | [1,15]  | [1,34]     |              |               | -{16}                 |            |       15 |
| 0 2  | [1,2]   | [1,34]     |              |               | -{15,16}              |            |        2 |
| 0 3  | [1,1]   | [1,34]     |              | [1,34]        | -{2,15,16}            |            |        1 |
| 1 0  | [1,34]  | [1,15]     |              |               | -{1,2,15,16}          |            |       14 |
| 1 1  | [1,17]  | [1,16]     | [1,15]       |               | -{1,2,[14,16]}        |            |       13 |
| 1 2  | [1,6]   | [1,29]     |              | [1,30]        | -{1,2,[13,16]}        |            |        6 |
| 1 3  | [1,1]   | [1,30]     |              |               | -{1,2,6,[13,16]}      |            |          |
| 1 2  | [1,6]   | [1,29]     |              | [1,30]        | -{1,2,[13,16]}        | -{6}       |        5 |
| 1 3  | [1,2]   | [1,30]     |              |               | -{1,2,5,[13,16]}      |            |          |
| 1 2  | [1,6]   | [1,29]     |              | [1,30]        | -{1,2,[13,16]}        | -{5,6}     |        4 |
| 1 3  | [1,3]   | [1,30]     |              |               | -{1,2,5,[13,16]}      |            |        3 |
| 2 1  | [1,34]  | [1,3]      |              |               | -{[1,3],5,[13,16]}    |            |          |
| 1 3  | [1,3]   | [1,30]     |              |               | -{1,2,5,[13,16]}      | -{3}       |          |
| 1 2  | [1,6]   | [1,29]     |              | [1,30]        | -{1,2,[13,16]}        | -{4,5,6}   |        3 |
| 1 3  | [1,4]   | [1,30]     |              |               | -{[1,3],[13,16]}      |            |        4 |
| 2 1  | [1,34]  | [1,3]      |              |               | -{[1,4],[13,16]}      |            |          |
| 1 3  | [1,4]   | [1,30]     |              |               | -{[1,3],[13,16]}      | -{4}       |          |
| 1 2  | [1,6]   | [1,29]     |              | [1,30]        | -{1,2,[13,16]}        | -{3,4,5,6} |          |
| 1 1  | [1,17]  | [1,16]     | [1,15]       |               | -{1,2,[14,16]}        | -{13}      |       12 |
| 1 2  | [1,7]   | [1,29]     |              | [1,30]        | -{1,2,12,[14,16]}     |            |        7 |
| 1 3  | [1,1]   | [1,30]     |              |               | -{1,2,7,12,[13,16]}   |            |          |
| 1 2  | [1,7]   | [1,29]     |              | [1,30]        | -{1,2,12,[14,16]}     | -{7}       |        6 |
| 1 3  | [1,2]   | [1,30]     |              |               | -{1,2,6,12,[13,16]}   |            |          |
| 1 2  | [1,7]   | [1,29]     |              | [1,30]        | -{1,2,12,[14,16]}     | -{6,7}     |        5 |
| 1 3  | [1,3]   | [1,30]     |              |               | -{1,2,5,12,[13,16]}   |            |        3 |
| 2 1  | [1,34]  | [1,4]      |              |               | -{[1,3],5,12,[14,16]} |            |        4 |
| 2 2  | [1,27]  | [1,4]      |              | [1,27]        | -{[1,5],12,[14,16]}   |            |          |
|      |         |            |              |               |                       |            |          |

| 16 | 15 | 2 | 1 |
| 14 | 12 | 5 | 3 |
|  4 |    |   |   |
|    |    |   |   |

I mean thats quite a few steps, but we have eliminated a good deal of the start-with-16 possibilities relatively quickly.

 I never looked into how constraint solvers are implemented under the hood, but it seems likely that its similar to this

 I also realize that I screwed up the upper bounds above, but thats ok, I think I am understanding the algorithm here

**** 3 Square Sample

 Ok, lets try one that we can (hopefully) make work in a reasonable amount of time. We'll start with the first row of a 3-square filled out and - importantly - filled out correctly.

| Cell | Row Sum | Column Sum | Diagonal Sum | Anti-diagonal | Uniqueness   | Disallowed | Decision |
|------+---------+------------+--------------+---------------+--------------+------------+----------|
| 1 0  | [1,12]  | [1,6]      |              |               | -{1,6,8}     |            |        5 |
| 1 1  | [1,9]   | [1,13]     | [1,6]        | [1,8]         | -{1,5,6,8}   |            |        4 |
| 1 2  | [6,6]   | [1,8]      |              |               | -{1,[4,6],8} |            |          |
| 1 1  | [1,9]   | [1,13]     | [1,6]        | [1,8]         | -{1,5,6,8}   | -{4}       |        3 |
| 1 2  | [7,7]   | [1,8]      |              |               | -{1,3,5,6,8} |            |        7 |
| 2 0  | [1,12]  | [2,2]      |              | [6,6]         | -{1,3,[5,8]} |            |          |
| 1 1  | [1,9]   | [1,13]     | [1,6]        | [1,8]         | -{1,5,6,8}   | -{3,4}     |        2 |
| 1 2  | [8,8]   | [1,8]      |              |               | -{1,2,5,6,8} |            |          |
| 1 0  | [1,12]  | [1,6]      |              |               | -{1,6,8}     | -{5}       |        4 |
| 1 1  | [1,10]  | [1,13]     | [1,6]        | [1,8]         | -{1,4,6,8}   |            |        5 |
| 1 2  | [6,6]   | [1,8]      |              |               | -{1,[4,6],8} |            |          |
| 1 1  | [1,10]  | [1,13]     | [1,6]        | [1,8]         | -{1,4,6,8}   | -{5}       |        3 |
| 1 2  | [8,8]   | [1,8]      | [1,3]        | [1,5]         | -{1,3,4,6,8} |            |          |
| 1 1  | [1,10]  | [1,13]     | [1,6]        | [1,8]         | -{1,4,6,8}   | -{3,5}     |        2 |
| 1 2  | [9,9]   | [1,8]      |              |               | -{1,2,4,6,8} |            |        9 |
| 2 0  | [1,12]  | [3,3]      |              | [7,7]         | -{...}       |            |          |
| 1 0  | [1,12]  | [1,6]      |              |               | -{1,6,8}     | -{4,5}     |        3 |
| 1 1  | [1,12]  | [1,13]     | [1,6]        | [1,8]         | -{1,3,6,8}   |            |        5 |
| 1 2  | [7,7]   | [1,7]      |              |               | -{1,3,5,6,8} |            |        7 |
| 2 0  | [1,12]  | [4,4]      |              | [4,4]         | -{1,3,[5,8]} |            |        4 |
| 2 1  | [1,10]  | [9,9]      |              |               | -{1,[3,8]}   |            |        9 |
| 2 2  | [2,2]   | [2,2]      | [2,2]        |               | -{1,[3,9]}   |            |        2 |

| 8 | 1 | 6 |
| 3 | 5 | 7 |
| 4 | 9 | 2 |

I honestly don't even care about the problem anymore, just implementing a constraint solver will be fun

*** Implementation

**** Setup

I also just learned about the ~type~ keyword which is cool but comes from python 3.12 so I need that. I want to be able to do some type checking and linting live and I want to practice using uv which I haven't touched before but seems to be gaining steam, I've created [[./constraint-solver/pyproject.toml][a pyproject.toml]] file for it and lets set it up


#+begin_src emacs-lisp  :results silent
  (async-shell-command "
    uv venv
    uv pip install -e '.[dev]'
  ")
#+end_src

Lets set
#+begin_src emacs-lisp
  (setq projectile-project-compilation-dir "./magic-square-generation/constraint-solver")
#+end_src
and now we can run [[elisp:(projectile-test-command)][projectile-test-command]] with ~watchexec -e py -r -- "uv run mypy *.py && uv run ruff check ."~ (make sure to ~pyenv-deactivate~ first)

I honestly don't see where pandas helps with this.
**** Basic structures
Lets create our basic structures and type aliases

#+begin_src python
  from dataclasses import dataclass, field
  from abc import ABC, abstractmethod
  from typing import Iterable, Tuple

  type Position = Tuple[int, int]
  type CellValue = int
  type MagicSquareCells = dict[Position, CellValue]

  @dataclass(frozen=True)
  class MagicSquareBuilder:
      """A magic square that is in process of being constructed."""
      cells: MagicSquareCells
      side_size: int
      span_sum: int = field(init=False)

      def __post_init__(self) -> None:
          # Using Godel's(?) equation for summing up sequential sequences / square_size
          object.__setattr__(self, 'span_sum', self.side_size*(1+self.side_size**2)/2)

      def set(self, position: Position, value: CellValue) -> "MagicSquareBuilder":
          new_cells = {**self.cells, position: value}
          return MagicSquareBuilder(cells=new_cells, side_size=self.side_size)
#+end_src
**** Constraints

Constraints are going to be just filters of possibilities given a square and a position in the square. A possibility will just be an integer. In theory you could metaprogram to your hearts content there, within the constraints we are using, it seems reasonable to say that a possibility is just an exact integer

#+begin_src python
  type Possibility = int

  @dataclass(frozen=True)
  class Constraint(ABC):
      """Abstract base class for constraints on a magic square."""
      square: MagicSquareBuilder
      position: Position

      @abstractmethod
      def filter(self, possibilities: Iterable[Possibility]) -> Iterable[Possibility]:
          """
          Filter down the given possibilities based on this constraint.
          """
          pass
#+end_src

So now implement the ~UniquenessConstraint~
#+begin_src python
  @dataclass(frozen=True)
  class UniquenessConstraint(Constraint):
      def filter(self, possibilities: Iterable[Possibility]) -> Iterable[Possibility]:
          square_values = set(self.square.cells.values())
          return (p for p in possibilities if p not in square_values)
#+end_src

And now we've got the sum constraints, they all have similar behavior
#+begin_src python
  @dataclass(frozen=True)
  class RowSumConstraint(Constraint):
      def filter(self, possibilities: Iterable[Possibility]) -> Iterable[Possibility]:
          r,c = self.position
          sum_before_position = sum((self.square.cells[(rb,c)] for rb in range(0,r)))
          lowest_possible_sum_after_position = int((self.square.side_size-r-1)*(self.square.side_size-r)/2) # this cannot ever be odd

          maximum = self.square.span_sum - sum_before_position - lowest_possible_sum_after_position
          minimum = 1 if r+1<self.square.side_size else maximum

          return (p for p in possibilities if minimum <= p <= maximum)

  @dataclass(frozen=True)
  class ColumnSumConstraint(Constraint):
      def filter(self, possibilities: Iterable[Possibility]) -> Iterable[Possibility]:
          r,c = self.position
          sum_before_position = sum((self.square.cells[(r,cb)] for cb in range(0,c)))
          lowest_possible_sum_after_position = int((self.square.side_size-c-1)*(self.square.side_size-c)/2) # this cannot ever be odd

          maximum = self.square.span_sum - sum_before_position - lowest_possible_sum_after_position
          minimum = 1 if c+1<self.square.side_size else maximum

          return (p for p in possibilities if minimum <= p <= maximum)

  @dataclass(frozen=True)
  class DiagonalSumConstraint(Constraint):
      def filter(self, possibilities: Iterable[Possibility]) -> Iterable[Possibility]:
          r,c = self.position
          if r != c:
              return possibilities
          sum_before_position = sum((self.square.cells[(rb,rb)] for rb in range(0,r)))

          lowest_possible_sum_after_position = int((self.square.side_size-r-1)*(self.square.side_size-r)/2) # this cannot ever be odd

          minimum = 1
          maximum = self.square.span_sum - sum_before_position - lowest_possible_sum_after_position
          minimum = 1 if r+1<self.square.side_size else maximum

          return (p for p in possibilities if minimum <= p <= maximum)

  @dataclass(frozen=True)
  class AntiDiagonalSumConstraint(Constraint):
      def filter(self, possibilities: Iterable[Possibility]) -> Iterable[Possibility]:
          r,c = self.position
          if r + 1 != self.square.side_size - c:
              return possibilities
          sum_before_position = sum((self.square.cells[(rb,(self.square.side_size-rb-1))] for rb in range(0,r)))

          lowest_possible_sum_after_position = int((self.square.side_size-r-1)*(self.square.side_size-r)/2) # this cannot ever be odd

          minimum = 1
          maximum = self.square.span_sum - sum_before_position - lowest_possible_sum_after_position
          minimum = 1 if r+1<self.square.side_size else maximum

          return (p for p in possibilities if minimum <= p <= maximum)
#+end_src

And finally we need a way of emitting the full range of possibilties
#+begin_src python
  def get_possibilities(square: MagicSquareBuilder) -> Iterable[Possibility]:
      return range(1, square.side_size**2+1)
#+end_src

Lets try these out
#+begin_src python :tangle no :results output pp replace
  cells = {(0,0): 8, (0,1): 1, (0,2): 6,
           (1,0): 3,
          }
  pos = (1,1)
  square = MagicSquareBuilder(cells=cells, side_size=3)
  filters = (
      UniquenessConstraint(square, pos),
      RowSumConstraint(square, pos), ColumnSumConstraint(square, pos),
      DiagonalSumConstraint(square, pos), AntiDiagonalSumConstraint(square, pos),
  )

  possibilities = list(get_possibilities(square))
  for f in filters:
      print("possibilities are", possibilities, "invoking", type(f))
      possibilities = list(f.filter(possibilities))

  print(list(possibilities))
#+end_src

#+RESULTS:
: possibilities are [1, 2, 3, 4, 5, 6, 7, 8, 9] invoking <class '__main__.UniquenessConstraint'>
: possibilities are [2, 4, 5, 7, 9] invoking <class '__main__.RowSumConstraint'>
: possibilities are [2, 4, 5, 7, 9] invoking <class '__main__.ColumnSumConstraint'>
: possibilities are [2, 4, 5, 7, 9] invoking <class '__main__.DiagonalSumConstraint'>
: possibilities are [2, 4, 5] invoking <class '__main__.AntiDiagonalSumConstraint'>
: [2, 4, 5]

That seems right

**** Implementing our search

Now lets do our find

#+begin_src python
  def possibilities_to_values(possibilities: Iterable[Possibility]) -> Iterable[CellValue]:
      return possibilities # For now that is all this is, at some point later we might be handling ranges here

  def fill_magic_square(square: MagicSquareBuilder, remaining_positions: list[Position]) -> None | MagicSquareBuilder:
      if not square or not remaining_positions:
          return square

      position, *other_positions = remaining_positions

      filters = (
          UniquenessConstraint(square, position),
          RowSumConstraint(square, position),
          ColumnSumConstraint(square, position),
          DiagonalSumConstraint(square, position),
          AntiDiagonalSumConstraint(square, position),
      )

      possibilities = get_possibilities(square)
      for f in filters:
          possibilities = f.filter(possibilities)

      for value in possibilities_to_values(possibilities):
          resulting_filled_square = fill_magic_square(square.set(position, value), other_positions)
          if resulting_filled_square:
              return resulting_filled_square

      return None
#+end_src

lets try this
#+begin_src python :tangle no :results output pp replace
  print( fill_magic_square(square, [(1,1),(1,2),(2,0),(2,1),(2,2)]) )
#+end_src

#+RESULTS:
: MagicSquareBuilder(cells={(0, 0): 8, (0, 1): 1, (0, 2): 6, (1, 0): 3, (1, 1): 5, (1, 2): 7, (2, 0): 4, (2, 1): 9, (2, 2): 2}, side_size=3, span_sum=15.0)

Nice. What about an impossible magic square?

#+begin_src python :tangle no :results output pp replace
  print( fill_magic_square(square.set((1,0), 5), [(1,1),(1,2),(2,0),(2,1),(2,2)]) )
#+end_src

#+RESULTS:
: None

Correct, now here's the top level ~find_magic_square~ along with a helpful print function
#+begin_src python
  def find_magic_square(size: int) -> None | MagicSquareBuilder:
      square = MagicSquareBuilder(cells={}, side_size=size)
      positions = list((r, c) for r in range(size) for c in range(size))
      final_square = fill_magic_square(square, positions)
      return final_square

  def print_magic_square(square: MagicSquareBuilder | None) -> None:
      if not square:
          print("No such square")
          return

      for r in range(square.side_size):
          print('\t'.join([str(square.cells[r,c]) for c in range(square.side_size)]))

#+end_src

Finally, lets lets make that main function. I want two additional features here since I'm having problems with performance
- A profiler
- A timeout built into the python script (so I can still print profile data when the function times out)
#+begin_src python
  if __name__ == "__main__":
      import sys
      import cProfile
      import pstats
      import signal
      import time
      from pstats import SortKey

      if len(sys.argv) > 1:
          size = int(sys.argv[1])
          timeout_seconds = int(sys.argv[2]) if len(sys.argv) > 2 else 10

          profiler = cProfile.Profile()
          profiler.enable()

          def timeout_handler(signum, frame):
              raise TimeoutError("Computation timed out")

          signal.signal(signal.SIGALRM, timeout_handler)
          signal.alarm(timeout_seconds)

          square = None
          start_time = time.time()
          try:
              square = find_magic_square(size)
              signal.alarm(0)
          except TimeoutError:
              print(f"\nComputation timed out after {timeout_seconds} seconds")
          finally:
              elapsed_time = time.time() - start_time
              profiler.disable()

              print(f"\nMagic Square Result (after {elapsed_time:.2f} seconds):")
              print_magic_square(square)

              print("\nProfiling Results:")
              stats = pstats.Stats(profiler).sort_stats(SortKey.CUMULATIVE)
              stats.print_stats(20)  # Print top 20 functions by cumulative time
#+end_src

Now lets test that

#+begin_src python :tangle no :results output pp replace
  print_magic_square( find_magic_square(3) )
#+end_src

#+RESULTS:
: 2	7	6
: 9	5	1
: 4	3	8

#+begin_src python :tangle no :results output pp replace
  print_magic_square( find_magic_square(4) )
#+end_src

#+RESULTS:
: 1	2	15	16
: 12	14	3	5
: 13	7	10	4
: 8	11	6	9

wow nice! very quick

a 5-square not so much though, lets run it as a script so that we get all timeout and profiling goodies

#+begin_src shell :results verbatim :var script_name=(org-entry-get (point) "tangle-target" 't)
  uv run python "../$script_name" 5 2>&1
#+end_src

#+RESULTS:
#+begin_example

Computation timed out after 10 seconds

Magic Square Result (after 10.00 seconds):
No such square

Profiling Results:
         24878674 function calls (24227222 primitive calls) in 8.695 seconds

   Ordered by: cumulative time
   List reduced from 36 to 20 due to restriction <20>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000   10.000   10.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:145(find_magic_square)
 651453/1    2.651    0.000   10.000   10.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:118(fill_magic_square)
  1617729    0.758    0.000    1.482    0.000 {built-in method builtins.sum}
  1424596    0.290    0.000    1.473    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:74(<genexpr>)
  1636050    0.629    0.000    1.184    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:62(<genexpr>)
   651453    0.514    0.000    1.122    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:66(filter)
   651453    0.526    0.000    1.109    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:54(filter)
   651452    0.415    0.000    0.968    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:21(set)
   582101    0.116    0.000    0.763    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:90(<genexpr>)
   651453    0.485    0.000    0.561    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:46(filter)
  5071000    0.555    0.000    0.555    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:48(<genexpr>)
   651453    0.271    0.000    0.543    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:78(filter)
  2823769    0.300    0.000    0.300    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:68(<genexpr>)
  2590314    0.283    0.000    0.283    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:56(<genexpr>)
   651453    0.232    0.000    0.232    0.000 <string>:2(__init__)
   651453    0.192    0.000    0.192    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:17(__post_init__)
  1185721    0.131    0.000    0.131    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:82(<genexpr>)
   651453    0.126    0.000    0.126    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:110(get_possibilities)
   651453    0.076    0.000    0.095    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:94(filter)
    57091    0.022    0.000    0.093    0.000 /home/gmauer/code/daily-programmer/magic-square-generation/constraint-solver/../constraint-solver/magic_square_generation.py:106(<genexpr>)


#+end_example

Damn, that one still timed out. It's such a huge ramp up in execution time that I feel no amount of optimization will help us get to 9.

**** Optimization Brainstorming
Brainstorming some other optimizations that I *could* do
- Obviously unrolling the recursive function, though the recursion doesn't seem to be too much of an issue here
- ~1/Nth~ of the time the sum constraints will be in the ~miminum = maximum~ state in which case there's no need to iterate possibilities just to check if they contain ~minimum~
- Interestingly, its spending significantly more time in the ~ColumnSumConstraint~ which comes second than in the ~RowSumConstraint~, I don't really have a theory as to why
- We could pre-calculate what numbers we are going to try for the row so we do not waste time on things that cannot be a row sum. In fact now that I think of it, how many combinations are there total of sets of numbers that could add up to ~S~? Maybe I should just precalculate all of those to try. For example for ~N=3~ the possibilities are
  | 12 | 2 | 1 |
  | 11 | 3 | 1 |
  | 10 | 4 | 1 |
  | 10 | 3 | 2 |
  |  9 | 5 | 1 |
  |  9 | 4 | 2 |
  |  8 | 6 | 1 |
  |  8 | 5 | 2 |
  |  8 | 4 | 3 |
  |  7 | 6 | 2 |
  |  7 | 5 | 3 |

  I think that's it? Just 11 possibilities each with 6 permutations of each? This is promising as a direction. This would be a wholly new direction to go in

  I can almost, but not quite see the pattern. Lets try the above again with 4 numbers \( [1,16] \) which add up to =34=

  | 16 | 15 |  2 | 1 |
  | 16 | 14 |  3 | 1 |
  | 16 | 14 |  2 |   |
  | 16 | 13 |  4 | 1 |
  | 16 | 13 |  3 | 2 |
  | 16 | 13 |  2 |   |
  | 16 | 12 |  5 | 1 |
  | 16 | 12 |  4 | 2 |
  | 16 | 12 |  3 |   |
  | 16 | 11 |  6 | 1 |
  | 16 | 11 |  5 | 2 |
  | 16 | 11 |  4 | 3 |
  | 16 | 11 |  3 |   |
  | 16 | 10 |  7 | 1 |
  | 16 | 10 |  6 | 2 |
  | 16 | 10 |  5 | 3 |
  | 16 | 10 |  4 |   |
  | 16 |  9 |  8 | 1 |
  | 16 |  9 |  7 | 2 |
  | 16 |  9 |  6 | 3 |
  | 16 |  9 |  5 | 4 |
  | 16 |  9 |  4 |   |
  | 16 |  8 |  9 |   |
  | 16 |  8 |    |   |
  | 16 |  8 |  7 | 3 |
  | 16 |  8 |  6 | 4 |
  | 16 |  8 |  5 |   |
  | 16 |  7 | 10 |   |
  | 16 |  7 |  9 |   |
  | 16 |  7 |  8 |   |
  | 16 |  7 |    |   |
  | 16 |  7 |  6 | 5 |
  | 16 |  7 |  5 |   |
  | 16 |  6 | 11 |   |
  | 16 |  6 | 10 |   |
  | 16 |  6 |  9 |   |
  | 16 |  6 |  8 |   |
  | 16 |  6 |  7 |   |
  | 16 |  6 |    |   |
  | 16 |  5 | 12 |   |
  |    |    |    |   |
  | 15 | 14 |  4 | 1 |
  | 15 | 14 |  3 | 2 |
  | 15 | 13 |  5 | 1 |
  | 15 | 13 |  4 | 2 |
  | 15 | 12 |  6 | 1 |
  | 15 | 12 |  5 | 2 |
  | 15 | 12 |  4 | 3 |
  | 15 | 11 |  7 | 1 |
  | 15 | 11 |  6 | 2 |
  | 15 | 11 |  5 | 3 |
  | 15 | 10 |  8 | 1 |
  | 15 | 10 |  7 | 2 |
  | 15 | 10 |  6 | 3 |
  | 15 | 10 |  5 | 4 |
  | 15 |  9 |  8 | 2 |
  | 15 |  9 |  7 | 3 |
  | 15 |  9 |  6 | 4 |
  | 15 |  8 |  7 | 4 |
  | 15 |  8 |  6 | 5 |
  | 15 |  7 |    |   |

  So basically you're counting upward in the rightmost column and downwards in all others


This...is actually kind of an interesting problem that I feel like can be a daily programmer of its own. It can be phrased like this:

Given a set of numbers \( [1,N] \) and a sum =S=, what are all sets of =K= numbers that add up to =S=
