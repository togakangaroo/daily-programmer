I am looking for a job now and my last six months have been more devops focused. Let's get back into some coding

For this I just asked Mistral to cook me up a simple problem, here's what it gave me

* Problem Statement

In a magic square, all of the numbers from =1= to =n^2= appear, and the sums of the numbers in any row, column, or diagonal are always equal. Given an integer ~n (1 <= n <= 9)~, write a function that creates an
and returns such a magic square for the given size.

Here is an example of a =3x3= magic square:
#+begin_quote
[8, 1, 6]
[3, 5, 7]
[4, 9, 2]
#+end_quote


Create a function called =magicSquare= that takes in an integer =n= and returns a 2D list representing the magic square for the given size.

** Example:
#+begin_src python :eval no
magic_square(3) == [[8, 1, 6], [3, 5, 7], [4, 9, 2]]
#+end_src

** Constraints:
- The function should be able to handle any valid input from =1 to 9=.
- Use only basic data structures and built-in functions (avoid external libraries).


* Brainstorming
:PROPERTIES:
:header-args:python+: :eval no
:END:
A quick Google seems to indicate that magic squares are always possible, or at least possible enough that I think the constraints of the problem make sense. Sounds like there's "simple" techniques to do it. Maybe I'll look into those for a second implementation after I do this one.

I also want to use python because eh, it keeps coming up lately. I'll probably use elisp later.

Now what do we actually do? Well, a depth first search seems like the obvious thing, right?

In fact we know what the sum of every span (column, row, diagonal) in the square must be - it must be ~sum(1..n^2)/n~ which for a 3-quare would be ~45/3=15~. We could shortcut the DFS process by picking a number, then checking if that forces the sum of any spans to exceed it.

Additionally we *could* set a lower bound as well. If you are in a 3-square row that already contains a =1= then a =2= is out of the question since there would be no way to get to =15= with that. We could generalize it as a branch being a dead end if the row's current sum ~sum(span)~ plus the highest values possible in the remaining cells (~sum(n, n-1, n-2)~ ~n-len(span) times~) is less than our =Target= from above. This is good to know but feels more complicated thatn it might be worth within our constraints so lets punt on it.

Now, what sort of datastructure would be good here? What comes to mind is a 2d structure comprised of linked lists so that you can easily get the current spans as we go. Even though I'm picturing actually putting values into cells, it is probably best that this thing be immutable just because that works better for the detph first search, right? Lets write down the sort of operations we want to be able to do easily:

#+begin_src python
  new_square = set(square, row=0, column=2, value=7)
#+end_src
and the check for sums would be something like this

This seems like a good idea at first for an api
#+begin_src python
  if any((target_sum != sum(span) for span in get_spans(new_square, row=0, column=2))):
      return
#+end_src

but wait, that's not quite right, a span that isn't filled out yet isn't going to be the right sum but is not a dead end either. So I guess we could delegate the whole thing to the set function so it would be impossible to enter an invalid state. ~try_set~ instead of ~set~ and return ~True~ or ~False~ as to whether it succeeded. That would be easy enough to check so long as we have some sort of ~undefined~ token we could ignore (or coerce to 0 which works for the purposes of summing).

Finally I want to think about the structure. We really do need immutability I feel unless we want to be really invested in fastidiously cleaning up after each and every depth first search. Now normally I would say that some sort of copy-on-write implementation is what we want, but in this case we're simply storing integers. Copy-on-write would typically work by storing references to the "immutable" bits but that would just be references which aren't any smaller on the stack than integers are, right? I'm sure there's stuff you can do to make improvements here but at such small =n= it just doesn't seem like such a big deal to copy all the numbers in our square on each ~try_set()~

---

Ok, so that's one approach, lets just do a simple version of it. In fact, lets use my favorite approach of picturing ourselves physically on the problem space

I picture standing on a square grid with a book of available numbers. I tear down the page for the first number and pin it to the square, I then move forward and pin the next and I do this all the way across until I have pinned a number to each square. At that point I am done and I can check if it is a magic square. If it is, then hooray we did good; but, if not, then we must remove the last two notes and try things in a different order. Of course we know that this won't work but we can optimize in a bit. By repeating this process we will have successfully brute forced a solution.

Ok, but what about the optimization? Well it is important to understand that for a square of size =N=, each row, column, and diagonal must sum to

$$ \frac{N^2(N^2+1)}{2N} $$ which can be simplified as $$ \frac{N(N^2+1)}{2} $$ and represented as =T=

If we ever hit the following conditions then we can stop exploring as it is impossible to get a magic square from that state

- a row, column, or diagonal with a ~sum > T~
- a completed row, column, or diagonal with a ~sum != T~

Furthermore, if we can assume move top left to bottom right, if a completed row does not ~sum == T~ then no variation of that row will work. You could say the same thing of the ~/~ diagonal and columns as well, but under this assumption you wouldn't complete any of these until the last row so it doesn't save you on all that much iterations.

Also, you know what? I want to push myself a bit, I have only passing experience with Pandas, and I know it implements copy-on-write semantics for =DataFrame= so - even though it might not be the most efficient, lets learn something and do this with pandas


* Python Solution
:PROPERTIES:
:header-args:python+: :session magic-square-generation
:header-args:python+: :results silent
:header-args:python+: :tangle  (org-entry-get (point) "tangle-target" 't)
:END:

** Naive Attempt 1
:PROPERTIES:
:tangle-target: magic_square_generation_attempt_1.py
:END:
First some types and imports
#+begin_src python
  import pandas as pd
  import numpy as np
  from typing import Iterable
  from dataclasses import dataclass, field

  MagicSquareCells = pd.DataFrame

  @dataclass(frozen=True)
  class Position:
      row: int
      column: int
#+end_src

lets also build out a class for our magic square builder with some helper values set. Note that it's a ~Builder~ not a ~MagicSquare~ since we don't want it to be possible to create invalid objects (ie a magic square that is not actually magic)
#+begin_src python
  @dataclass(frozen=True)
  class MagicSquareBuilder:
      cells: MagicSquareCells
      side_size: int = field(init=False)
      max_span_sum: int = field(init=False)

      def __post_init__(self):
          object.__setattr__(self, 'side_size', self.cells.shape[0])
          # Using Godel's(?) equation for summing up sequential sequences / square_size
          object.__setattr__(self, 'max_span_sum', self.side_size*(1+self.side_size**2)/2)
#+end_src

We need a way to tell if a completed square is indeed magic, and that's going to be a bunch of our pandas stuff. I could make this stuff into methods on the class, but really its all in one module and typed so I see little point to it for the purposes of this exercise.

#+begin_src python
  def is_magic_square(square: MagicSquareBuilder) -> bool:
      row_sums = square.cells.sum(axis=1)
      first_row_sum = row_sums.iloc[0]
      all_rows_equal = (row_sums == first_row_sum).all()
      if not all_rows_equal:
          return False
      col_sums = square.cells.sum(axis=0)
      all_cols_sum_same_as_rows = (col_sums == first_row_sum).all()
      if not all_cols_sum_same_as_rows:
          return False
      return first_row_sum == np.diag(square.cells.values).sum() == np.diag(np.fliplr(square.cells.values)).sum()
#+end_src
#+begin_src python :results output pp replace :tangle no
  print(is_magic_square(MagicSquareBuilder(cells=pd.DataFrame([[1,2],[3,4]])))) # should be false
  magic_square = MagicSquareBuilder(cells=pd.DataFrame([
      [8, 1, 6],
      [3, 5, 7],
      [4, 9, 2],
  ]) )
  print(is_magic_square(magic_square))# should be true
#+end_src

#+RESULTS:
: False
: True

Ok, that works well. Now we need a way of setting a new value in our builder. A ~try_set~ function will allow us to run some basic checks before setting a value into a new copy of the builder. We want to make sure we're creating new instances since otherwise we'd have to clean up when unwinding the stack. I also believe that pandas might have some optimization around copying that can serve us well. At the very least, I see an article discussing that in Pandas 3.0 (which I'm not on yet).

**Assumption**: Here we are counting on the assumption that movement is top left to bottom right and that any filled values are filled with =0=

#+begin_src python
  def _potential_span_sums(square: MagicSquareBuilder, position: Position) -> Iterable[int]:
      row, column = position
      yield square.cells.iloc[row, :].values.sum()
      yield square.cells.iloc[:, column].values.sum()

      # \ Diagonal (main diagonal)
      if row == column:
          yield np.diag(square.cells.values).sum()

      # / Diagonal (anti-diagonal)
      if row == square.side_size - column - 1:
          yield np.diag(np.fliplr(square.cells.values)).sum()

  def try_set(square: MagicSquareBuilder, position: Position, value: int) -> None | MagicSquareBuilder:
      """Return a new square with position set to the passed in value. This will
      do some basic checking to ensure that the returned square could potentially
      still be a magic square. If not it will return None.
      """

      span_sums = _potential_span_sums(square, position)
      if any((square.max_span_sum < (x + value)) for x in span_sums):
          return None

      new_cells = square.cells.copy()
      new_cells.iloc[*position] = value
      return MagicSquareBuilder(cells=new_cells)
#+end_src

Lets experiment with that one

#+begin_src python :results output pp replace :tangle no
  incomplete_square = MagicSquareBuilder(cells=pd.DataFrame(np.zeros((3, 3), dtype=int)))
  print(try_set(incomplete_square, (2, 1), 20)) #should be none
  print(try_set(incomplete_square, (0, 1), 1)) #should be fine
#+end_src

#+RESULTS:
: None
: MagicSquareBuilder(cells=   0  1  2
: 0  0  1  0
: 1  0  0  0
: 2  0  0  0, side_size=3, max_span_sum=15.0)


Ok, so now lets actually implement the depth first search where we move from position to position and try to set values, drilling down to the next level if setting succeeds

#+begin_src python
  remaining_recursions = 100000
  def fill_magic_square(square: None | MagicSquareBuilder, remaining_positions: list[Position], remaining_values_to_try: list[int]) -> None | MagicSquareBuilder:
      assert len(remaining_positions) == len(remaining_values_to_try)
      global remaining_recursions

      assert 0 < remaining_recursions
      remaining_recursions -= 1

      if not remaining_positions:
          return square if is_magic_square(square) else None

      position_to_set, *other_positions = remaining_positions

      for value in remaining_values_to_try:
          square_with_value = try_set(square, position_to_set, value)
          if not square_with_value:
              continue
          all_other_values_to_try = [v for v in remaining_values_to_try if v != value]
          filled_square_with_value = fill_magic_square(square_with_value, other_positions, all_other_values_to_try)
          if filled_square_with_value:
              return filled_square_with_value

      return None

  def find_magic_square(size: int) -> None | MagicSquareCells:
      # While prefilling with zeros is not technically correct and would in many situations be better
      # to use nan, when working specifically with magic squares it kind of doesn't matter and
      # prefilling with zeros is just more efficient
      square = MagicSquareBuilder(cells=pd.DataFrame(np.zeros((size, size), dtype=int)))
      positions = list((r, c) for r in range(size) for c in range(size))
      all_values = list(range(1, size**2+1))
      square = fill_magic_square(square, positions, all_values)
      return square and square.cells
#+end_src

Lets try it

#+begin_src python :results output pp replace :tangle no
  print(find_magic_square(2)) # should be None
  print(find_magic_square(3)) # sould be a square
#+end_src

#+RESULTS:
: None
:    0  1  2
: 0  2  7  6
: 1  9  5  1
: 2  4  3  8


Wahoo that works, its not the most efficient but it does work. Although I notice that it is taking forever and I hit timeouts even on values as low as 4

#+begin_src python
if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        find_magic_square(int(sys.argv[1]))
#+end_src

#+RESULTS:

#+begin_src shell :results verbose :var script_name=(org-entry-get (point) "tangle-target" 't)
  timeout 10s python $script_name 4 2>&1
  echo $?
#+end_src

#+RESULTS:
: 124

Ok, so what I did is just too damn slow even for our limited constraints. Perhaps we can try to speed it up. I'm not ready to blame this all on Pandas just yet

** Attempt 2 - Constraint Solver
:PROPERTIES:
:tangle-target: magic_square_generation_attempt_2.py
:END:

*** Brainstorming
Lets change the model to one of constraints. Here the idea is that we can fill out rows one at a time

| 2 |   |   |

Well we clearly can answer the remaining set of possibilities: ~{(1,13),(3,10),(4,9),(5,8),(6,7)}~ where each pair can go in any order. This can even be cached.

Now lets say we get to

| 2 | 7 | 6 |
| 9 |   |   |

The possibilities for the row are ~{(1,5),(2,4)}~, and for the column are ~{(2,6),(3,5)}~, for the dialgonal are ~{(1,13),(3,10),(4,9),(5,8),(6,7)}~ and for the anti-diagonal are ~{(1,8),(2,7),(4,5)}~. We flatten these sets and take the intersection and only one possiblity remains =5=. #e can go further and subtract from this the set of already used numbers to narrow it down further

Lets try this again but run through it till we hit a dead end. Also for the sake of expediency lets start at a high number

| 10 |   |   |

The remaining possibilities are ~{(1,4),(2,3)}~ we don't have anything else to go off of so lets pick that first tuple and fill it out before moving on to the next row. If this doesn't work out we can try out the next later

| 10 | 1 | 4 |
|    |   |   |

The possibilities on the row are all the variants but on the column are once more  ~{(1,4),(2,3)}~ so the intersection is those four numbers flattened. Subtracting out the set of already used values we are left with a possibility of ~{(2,3)}~.

Not having anything else to go on, lets prefill things in that order but we *were* just at another decision point.

| 10 | 1 | 4 |
|  2 |   |   |
|  3 |   |   |

Now for the rest of row[1] the possible values are ~{(1,13),(3,10),(4,9),(5,8),(6,7)}~, the possible column values are ~{(2,12),(3,11),(4,10),(5,9),(6,8)}~, the possible diagonals are ~{(1,4),(2,3)}~ and anti-diagonals are ~{(1,10),(2,9),(3,8),(5,6)}~. Flatten the and intersect and you get ~{3}~. That's not enough values to fill the row so we've hit a dead end. Lets back it up to the previous decision point

| 10 | 1 | 4 |
|  3 |   |   |
|  2 |   |   |

Now for the rest of row[1] the possible values are ~{(1,11),(2,10),(4,8),(5,7)}~, the possible column values are ~{(2,12),(3,11),(4,10),(5,9),(6,8)}~, the possible diagonals are ~{(1,4),(2,3)}~ and anti-diagonals are ~{(1,10),(2,9),(3,8),(5,6)}~. Flatten the and intersect and you get ~{2}~. Once again, that's not enough values to fill the row so we've hit a dead end.

Lets try that again but without any pairwise thoughts

| 10 |   |   |

The remaining possibilities are ~{1,2,3,4}~ lets pick the first Decision point!

| 10 | 1 |   |

The reminaing possibilities are ~4~, there isn't really a decision here for a 3x3 but would be for more

| 10 | 1 | 4 |
|    |   |   |

rows are unconstrained, column is contstrained to ~{1,2,3,4}~ subtract out the already used to get ~{2,3}~ and pick the first at a decision point

| 10 | 1 | 4 |
|  2 |   |   |

the next value is now constrained by row to ~{1,3,4,5,6,7,8,9,10}~ and by column to ~{2,3,4,5,6,7,8,9,10}~ by diagonal to ~{1,2,3,4}~ and by anti-diagonal to ~{1,2,3,4,5,6,7,8,9,10}~. This gives us an intersection of ~{3,4}~ and when you subtract all the used ones you get ~{3}~. Dead end!

Rolling back to the previous decision point

| 10 | 1 | 4 |
|  3 |   |   |

the next value is now constrained by row to ~{1,2,4,5,6,7,8,9,10}~ and by column to ~{2,3,4,5,6,7,8,9,10}~ by diagonal to ~{1,2,3,4}~ and by anti-diagonal to ~{1,2,3,4,5,6,7,8,9,10}~. This gives us an intersection of ~{2,4}~ and when you subtract all the used ones you get ~{2}~. Dead end! Our previous decision point was all the way back on position 2

| 10 | 2 |   |


| 10 | 2 | 3 |
|    |   |   |

rows are unconstrained, column is contstrained to ~{1,2,3,4}~ subtract out the already used to get ~{1,4}~ and pick the first at a decision point

| 10 | 2 | 3 |
|  1 |   |   |

the next value is now constrained by row to ~{2,3,4,5,6,7,8,9,10}~ and by column to ~{1,3,4,5,6,7,8,9,10}~ by diagonal to ~{1,2,3,4}~ and by anti-diagonal to ~{1,2,4,5,6,7,8,9,10}~. This gives us an intersection of ~{2,4}~ and when you subtract all the used ones you get ~{4}~. Dead end!

At this point I am noticing that we're just reflecting the square from above. I guess once we eliminate a set of values for row 1 we could *also* eliminate them for column 1. This might be like overkill as an optimization for our needs though I'm sure it can halve some runtimes.

Ok, we'll do this one more time but on a ~N=4~, =4x4= square.

I'm also going to be really methodical here with making my steps explicit and listing all constraints. Some universal constraints that we will be applying are

**** Defining our Constraints
- Known Value :: Must be in \( [1, N^2] = [1,16] \)
- Row Sum :: Ensure the row sum is
    \( S = \frac{N(1+N^2)}{2} = 34 \)
  So when you're on row index =r= and the sum so far is =R=, the bounds will be \( [1, S-R ] \)
  Though we can actually decrease it further any *sum* of the range of cells after =r= must be possible. But the lowest possible sum for a number of cells =k= ...

  - When r=0 there are k=3 left after this one. \( R'=3+2+1=6 \)
  - When r=1 there's k=2 left. \( R'=2+1=3 \)
  - When r=2 there's k=1 left. \( R'=1 \)
  - When r=3 there's k=0 left. \( R'=0 \)
  In this case \( k=N-r-1 \). and \( R'=\frac{k(k+1)}{2} \)

  which we can subsitute in to get
  \begin{equation}
    \frac{(N-r-1)(N-r-1+1)}{2}
    \frac{(N-r-1)(N-r)}{2}
    \\=R'
  \end{equation}

  I think that's the neatest thing we could reduce it to? So we have this equation \( S = R + V[r] + R' \)

  And finally twe get

  \( [1, S-R-R'] \)

  which accounts for the fact that you don't want to sum up *all* the way to =S= before you get to the end.
  **Important Caveat*: If \( r+1=N \) then \( [S-R-R']=[S-R] \) is also the lowerbound
- Column Sum :: Ensure the same for column sum on column index =c= when the sum so far is =C=, the bounds will be \( [1, S-C-C'] \)
- Diagonal Sum :: When \( r=c \), the same for diagonal sum when the sum so far is =D=, the bounds will be \( [1, S-D-D'] \)
- Anti-Diagonal Sum :: When \( r=(N-c-1) \), the same for the anti-diagonal sum when the sum so far is =D_a=, the bounds will be \( [1, S-D_a-D_a'] \)
- Uniqueness :: Must not be one of the numbers already used
- Disallowed :: Values we already tried DFS when searching this decision point

**** 4 Square Sample

At each decision point we will pick the highest number possible. It shouldn't make a lot of difference but we can hopefully use it to cut down on some options.

We are going to move top left to bottom right, backtracking at each decision point as necessary.

| Cell | Row Sum | Column Sum | Diagonal Sum | Anti-diagonal | Uniqueness            | Disallowed | Decision |
|------+---------+------------+--------------+---------------+-----------------------+------------+----------|
| 0 0  | [1,34]  | [1,34]     | [1,34]       |               |                       |            |       16 |
| 0 1  | [1,15]  | [1,34]     |              |               | -{16}                 |            |       15 |
| 0 2  | [1,2]   | [1,34]     |              |               | -{15,16}              |            |        2 |
| 0 3  | [1,1]   | [1,34]     |              | [1,34]        | -{2,15,16}            |            |        1 |
| 1 0  | [1,34]  | [1,15]     |              |               | -{1,2,15,16}          |            |       14 |
| 1 1  | [1,17]  | [1,16]     | [1,15]       |               | -{1,2,[14,16]}        |            |       13 |
| 1 2  | [1,6]   | [1,29]     |              | [1,30]        | -{1,2,[13,16]}        |            |        6 |
| 1 3  | [1,1]   | [1,30]     |              |               | -{1,2,6,[13,16]}      |            |          |
| 1 2  | [1,6]   | [1,29]     |              | [1,30]        | -{1,2,[13,16]}        | -{6}       |        5 |
| 1 3  | [1,2]   | [1,30]     |              |               | -{1,2,5,[13,16]}      |            |          |
| 1 2  | [1,6]   | [1,29]     |              | [1,30]        | -{1,2,[13,16]}        | -{5,6}     |        4 |
| 1 3  | [1,3]   | [1,30]     |              |               | -{1,2,5,[13,16]}      |            |        3 |
| 2 1  | [1,34]  | [1,3]      |              |               | -{[1,3],5,[13,16]}    |            |          |
| 1 3  | [1,3]   | [1,30]     |              |               | -{1,2,5,[13,16]}      | -{3}       |          |
| 1 2  | [1,6]   | [1,29]     |              | [1,30]        | -{1,2,[13,16]}        | -{4,5,6}   |        3 |
| 1 3  | [1,4]   | [1,30]     |              |               | -{[1,3],[13,16]}      |            |        4 |
| 2 1  | [1,34]  | [1,3]      |              |               | -{[1,4],[13,16]}      |            |          |
| 1 3  | [1,4]   | [1,30]     |              |               | -{[1,3],[13,16]}      | -{4}       |          |
| 1 2  | [1,6]   | [1,29]     |              | [1,30]        | -{1,2,[13,16]}        | -{3,4,5,6} |          |
| 1 1  | [1,17]  | [1,16]     | [1,15]       |               | -{1,2,[14,16]}        | -{13}      |       12 |
| 1 2  | [1,7]   | [1,29]     |              | [1,30]        | -{1,2,12,[14,16]}     |            |        7 |
| 1 3  | [1,1]   | [1,30]     |              |               | -{1,2,7,12,[13,16]}   |            |          |
| 1 2  | [1,7]   | [1,29]     |              | [1,30]        | -{1,2,12,[14,16]}     | -{7}       |        6 |
| 1 3  | [1,2]   | [1,30]     |              |               | -{1,2,6,12,[13,16]}   |            |          |
| 1 2  | [1,7]   | [1,29]     |              | [1,30]        | -{1,2,12,[14,16]}     | -{6,7}     |        5 |
| 1 3  | [1,3]   | [1,30]     |              |               | -{1,2,5,12,[13,16]}   |            |        3 |
| 2 1  | [1,34]  | [1,4]      |              |               | -{[1,3],5,12,[14,16]} |            |        4 |
| 2 2  | [1,27]  | [1,4]      |              | [1,27]        | -{[1,5],12,[14,16]}   |            |          |
|      |         |            |              |               |                       |            |          |

| 16 | 15 | 2 | 1 |
| 14 | 12 | 5 | 3 |
|  4 |    |   |   |
|    |    |   |   |

I mean thats quite a few steps, but we have eliminated a good deal of the start-with-16 possibilities relatively quickly.

 I never looked into how constraint solvers are implemented under the hood, but it seems likely that its similar to this

 I also realize that I screwed up the upper bounds above, but thats ok, I think I am understanding the algorithm here

**** 3 Square Sample

 Ok, lets try one that we can (hopefully) make work in a reasonable amount of time. We'll start with the first row of a 3-square filled out and - importantly - filled out correctly.

| Cell | Row Sum | Column Sum | Diagonal Sum | Anti-diagonal | Uniqueness   | Disallowed | Decision |
|------+---------+------------+--------------+---------------+--------------+------------+----------|
| 1 0  | [1,12]  | [1,6]      |              |               | -{1,6,8}     |            |        5 |
| 1 1  | [1,9]   | [1,13]     | [1,6]        | [1,8]         | -{1,5,6,8}   |            |        4 |
| 1 2  | [6,6]   | [1,8]      |              |               | -{1,[4,6],8} |            |          |
| 1 1  | [1,9]   | [1,13]     | [1,6]        | [1,8]         | -{1,5,6,8}   | -{4}       |        3 |
| 1 2  | [7,7]   | [1,8]      |              |               | -{1,3,5,6,8} |            |        7 |
| 2 0  | [1,12]  | [2,2]      |              | [6,6]         | -{1,3,[5,8]} |            |          |
| 1 1  | [1,9]   | [1,13]     | [1,6]        | [1,8]         | -{1,5,6,8}   | -{3,4}     |        2 |
| 1 2  | [8,8]   | [1,8]      |              |               | -{1,2,5,6,8} |            |          |
| 1 0  | [1,12]  | [1,6]      |              |               | -{1,6,8}     | -{5}       |        4 |
| 1 1  | [1,10]  | [1,13]     | [1,6]        | [1,8]         | -{1,4,6,8}   |            |        5 |
| 1 2  | [6,6]   | [1,8]      |              |               | -{1,[4,6],8} |            |          |
| 1 1  | [1,10]  | [1,13]     | [1,6]        | [1,8]         | -{1,4,6,8}   | -{5}       |        3 |
| 1 2  | [8,8]   | [1,8]      | [1,3]        | [1,5]         | -{1,3,4,6,8} |            |          |
| 1 1  | [1,10]  | [1,13]     | [1,6]        | [1,8]         | -{1,4,6,8}   | -{3,5}     |        2 |
| 1 2  | [9,9]   | [1,8]      |              |               | -{1,2,4,6,8} |            |        9 |
| 2 0  | [1,12]  | [3,3]      |              | [7,7]         | -{...}       |            |          |
| 1 0  | [1,12]  | [1,6]      |              |               | -{1,6,8}     | -{4,5}     |        3 |
| 1 1  | [1,12]  | [1,13]     | [1,6]        | [1,8]         | -{1,3,6,8}   |            |        5 |
| 1 2  | [7,7]   | [1,7]      |              |               | -{1,3,5,6,8} |            |        7 |
| 2 0  | [1,12]  | [4,4]      |              | [4,4]         | -{1,3,[5,8]} |            |        4 |
| 2 1  | [1,10]  | [9,9]      |              |               | -{1,[3,8]}   |            |        9 |
| 2 2  | [2,2]   | [2,2]      | [2,2]        |               | -{1,[3,9]}   |            |        2 |

| 8 | 1 | 6 |
| 3 | 5 | 7 |
| 4 | 9 | 2 |

I honestly don't even care about the problem anymore, just implementing a constraint solver will be fun

**** Implementation
