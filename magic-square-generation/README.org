I am looking for a job now and my last six months have been more devops focused. Let's get back into some coding

For this I just asked Mistral to cook me up a simple problem, here's what it gave me

* Problem Statement

In a magic square, all of the numbers from =1= to =n^2= appear, and the sums of the numbers in any row, column, or diagonal are always equal. Given an integer ~n (1 <= n <= 9)~, write a function that creates an
and returns such a magic square for the given size.

Here is an example of a =3x3= magic square:
#+begin_quote
[8, 1, 6]
[3, 5, 7]
[4, 9, 2]
#+end_quote


Create a function called =magicSquare= that takes in an integer =n= and returns a 2D list representing the magic square for the given size.

** Example:
#+begin_src python :eval no
magic_square(3) == [[8, 1, 6], [3, 5, 7], [4, 9, 2]]
#+end_src

** Constraints:
- The function should be able to handle any valid input from =1 to 9=.
- Use only basic data structures and built-in functions (avoid external libraries).


* Brainstorming
:PROPERTIES:
:header-args:python+: :eval no
:END:
A quick Google seems to indicate that magic squares are always possible, or at least possible enough that I think the constraints of the problem make sense. Sounds like there's "simple" techniques to do it. Maybe I'll look into those for a second implementation after I do this one.

I also want to use python because eh, it keeps coming up lately. I'll probably use elisp later.

Now what do we actually do? Well, a depth first search seems like the obvious thing, right?

In fact we know what the sum of every span (column, row, diagonal) in the square must be - it must be ~sum(1..n^2)/n~ which for a 3-quare would be ~45/3=15~. We could shortcut the DFS process by picking a number, then checking if that forces the sum of any spans to exceed it.

Additionally we *could* set a lower bound as well. If you are in a 3-square row that already contains a =1= then a =2= is out of the question since there would be no way to get to =15= with that. We could generalize it as a branch being a dead end if the row's current sum ~sum(span)~ plus the highest values possible in the remaining cells (~sum(n, n-1, n-2)~ ~n-len(span) times~) is less than our =Target= from above. This is good to know but feels more complicated thatn it might be worth within our constraints so lets punt on it.

Now, what sort of datastructure would be good here? What comes to mind is a 2d structure comprised of linked lists so that you can easily get the current spans as we go. Even though I'm picturing actually putting values into cells, it is probably best that this thing be immutable just because that works better for the detph first search, right? Lets write down the sort of operations we want to be able to do easily:

#+begin_src python
  new_square = set(square, row=0, column=2, value=7)
#+end_src
and the check for sums would be something like this

This seems like a good idea at first for an api
#+begin_src python
  if any((target_sum != sum(span) for span in get_spans(new_square, row=0, column=2))):
      return
#+end_src

but wait, that's not quite right, a span that isn't filled out yet isn't going to be the right sum but is not a dead end either. So I guess we could delegate the whole thing to the set function so it would be impossible to enter an invalid state. ~try_set~ instead of ~set~ and return ~True~ or ~False~ as to whether it succeeded. That would be easy enough to check so long as we have some sort of ~undefined~ token we could ignore (or coerce to 0 which works for the purposes of summing).

Finally I want to think about the structure. We really do need immutability I feel unless we want to be really invested in fastidiously cleaning up after each and every depth first search. Now normally I would say that some sort of copy-on-write implementation is what we want, but in this case we're simply storing integers. Copy-on-write would typically work by storing references to the "immutable" bits but that would just be references which aren't any smaller on the stack than integers are, right? I'm sure there's stuff you can do to make improvements here but at such small =n= it just doesn't seem like such a big deal to copy all the numbers in our square on each ~try_set()~

---

Ok, so that's one approach, lets just do a simple version of it. In fact, lets use my favorite approach of picturing ourselves physically on the problem space

I picture standing on a square grid with a book of available numbers. I tear down the page for the first number and pin it to the square, I then move forward and pin the next and I do this all the way across until I have pinned a number to each square. At that point I am done and I can check if it is a magic square. If it is, then hooray we did good; but, if not, then we must remove the last two notes and try things in a different order. Of course we know that this won't work but we can optimize in a bit. By repeating this process we will have successfully brute forced a solution.

Ok, but what about the optimization? Well it is important to understand that for a square of size =N=, each row, column, and diagonal must sum to

$$ \frac{N^2(N^2+1)}{2N} $$ which can be simplified as $$ \frac{N(N^2+1)}{2} $$ and represented as =T=

If we ever hit the following conditions then we can stop exploring as it is impossible to get a magic square from that state

- a row, column, or diagonal with a ~sum > T~
- a completed row, column, or diagonal with a ~sum != T~

Furthermore, if we can assume move top left to bottom right, if a completed row does not ~sum == T~ then no variation of that row will work. You could say the same thing of the ~/~ diagonal and columns as well, but under this assumption you wouldn't complete any of these until the last row so it doesn't save you on all that much iterations.

Also, you know what? I want to push myself a bit, I have only passing experience with Pandas, and I know it implements copy-on-write semantics for =DataFrame= so - even though it might not be the most efficient, lets learn something and do this with pandas


* Python Solution
:PROPERTIES:
:header-args:python+: :session magic-square-generation
:header-args:python+: :results silent
:header-args:python+: :tangle  (org-entry-get (point) "tangle-target" 't)
:END:

** Naive Attempt
:PROPERTIES:
:tangle-target: magic_square_generation_attempt_1.py
:END:
First some types and imports
#+begin_src python
  import pandas as pd
  import numpy as np
  from typing import Iterable
  from dataclasses import dataclass, field

  MagicSquareCells = pd.DataFrame

  @dataclass(frozen=True)
  class Position:
      row: int
      column: int
#+end_src

lets also build out a class for our magic square builder with some helper values set. Note that it's a ~Builder~ not a ~MagicSquare~ since we don't want it to be possible to create invalid objects (ie a magic square that is not actually magic)
#+begin_src python
  @dataclass(frozen=True)
  class MagicSquareBuilder:
      cells: MagicSquareCells
      side_size: int = field(init=False)
      max_span_sum: int = field(init=False)

      def __post_init__(self):
          object.__setattr__(self, 'side_size', self.cells.shape[0])
          # Using Godel's(?) equation for summing up sequential sequences / square_size
          object.__setattr__(self, 'max_span_sum', self.side_size*(1+self.side_size**2)/2)
#+end_src

We need a way to tell if a completed square is indeed magic, and that's going to be a bunch of our pandas stuff. I could make this stuff into methods on the class, but really its all in one module and typed so I see little point to it for the purposes of this exercise.

#+begin_src python
  def is_magic_square(square: MagicSquareBuilder) -> bool:
      row_sums = square.cells.sum(axis=1)
      first_row_sum = row_sums.iloc[0]
      all_rows_equal = (row_sums == first_row_sum).all()
      if not all_rows_equal:
          return False
      col_sums = square.cells.sum(axis=0)
      all_cols_sum_same_as_rows = (col_sums == first_row_sum).all()
      if not all_cols_sum_same_as_rows:
          return False
      return first_row_sum == np.diag(square.cells.values).sum() == np.diag(np.fliplr(square.cells.values)).sum()
#+end_src
#+begin_src python :results output pp replace :tangle no
  print(is_magic_square(MagicSquareBuilder(cells=pd.DataFrame([[1,2],[3,4]])))) # should be false
  magic_square = MagicSquareBuilder(cells=pd.DataFrame([
      [8, 1, 6],
      [3, 5, 7],
      [4, 9, 2],
  ]) )
  print(is_magic_square(magic_square))# should be true
#+end_src

#+RESULTS:
: False
: True

Ok, that works well. Now we need a way of setting a new value in our builder. A ~try_set~ function will allow us to run some basic checks before setting a value into a new copy of the builder. We want to make sure we're creating new instances since otherwise we'd have to clean up when unwinding the stack. I also believe that pandas might have some optimization around copying that can serve us well. At the very least, I see an article discussing that in Pandas 3.0 (which I'm not on yet).

**Assumption**: Here we are counting on the assumption that movement is top left to bottom right and that any filled values are filled with =0=

#+begin_src python
  def _potential_span_sums(square: MagicSquareBuilder, position: Position) -> Iterable[int]:
      row, column = position
      yield square.cells.iloc[row, :].values.sum()
      yield square.cells.iloc[:, column].values.sum()

      # \ Diagonal (main diagonal)
      if row == column:
          yield np.diag(square.cells.values).sum()

      # / Diagonal (anti-diagonal)
      if row == square.side_size - column - 1:
          yield np.diag(np.fliplr(square.cells.values)).sum()

  def try_set(square: MagicSquareBuilder, position: Position, value: int) -> None | MagicSquareBuilder:
      """Return a new square with position set to the passed in value. This will
      do some basic checking to ensure that the returned square could potentially
      still be a magic square. If not it will return None.
      """

      span_sums = _potential_span_sums(square, position)
      if any((square.max_span_sum < (x + value)) for x in span_sums):
          return None

      new_cells = square.cells.copy()
      new_cells.iloc[*position] = value
      return MagicSquareBuilder(cells=new_cells)
#+end_src

Lets experiment with that one

#+begin_src python :results output pp replace :tangle no
  incomplete_square = MagicSquareBuilder(cells=pd.DataFrame(np.zeros((3, 3), dtype=int)))
  print(try_set(incomplete_square, (2, 1), 20)) #should be none
  print(try_set(incomplete_square, (0, 1), 1)) #should be fine
#+end_src

#+RESULTS:
: None
: MagicSquareBuilder(cells=   0  1  2
: 0  0  1  0
: 1  0  0  0
: 2  0  0  0, side_size=3, max_span_sum=15.0)


Ok, so now lets actually implement the depth first search where we move from position to position and try to set values, drilling down to the next level if setting succeeds

#+begin_src python
  remaining_recursions = 100000
  def fill_magic_square(square: None | MagicSquareBuilder, remaining_positions: list[Position], remaining_values_to_try: list[int]) -> None | MagicSquareBuilder:
      assert len(remaining_positions) == len(remaining_values_to_try)
      global remaining_recursions

      assert 0 < remaining_recursions
      remaining_recursions -= 1

      if not remaining_positions:
          return square if is_magic_square(square) else None

      position_to_set, *other_positions = remaining_positions

      for value in remaining_values_to_try:
          square_with_value = try_set(square, position_to_set, value)
          if not square_with_value:
              continue
          all_other_values_to_try = [v for v in remaining_values_to_try if v != value]
          filled_square_with_value = fill_magic_square(square_with_value, other_positions, all_other_values_to_try)
          if filled_square_with_value:
              return filled_square_with_value

      return None

  def find_magic_square(size: int) -> None | MagicSquareCells:
      # While prefilling with zeros is not technically correct and would in many situations be better
      # to use nan, when working specifically with magic squares it kind of doesn't matter and
      # prefilling with zeros is just more efficient
      square = MagicSquareBuilder(cells=pd.DataFrame(np.zeros((size, size), dtype=int)))
      positions = list((r, c) for r in range(size) for c in range(size))
      all_values = list(range(1, size**2+1))
      square = fill_magic_square(square, positions, all_values)
      return square and square.cells
#+end_src

Lets try it

#+begin_src python :results output pp replace :tangle no
  print(find_magic_square(2)) # should be None
  print(find_magic_square(3)) # sould be a square
#+end_src

#+RESULTS:
: None
:    0  1  2
: 0  2  7  6
: 1  9  5  1
: 2  4  3  8


Wahoo that works, its not the most efficient but it does work. Although I notice that it is taking forever and I hit timeouts even on values as low as 4

#+begin_src python
if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        find_magic_square(int(sys.argv[1]))
#+end_src

#+RESULTS:

#+begin_src shell :results verbose :var script_name=(org-entry-get (point) "tangle-target" 't)
  timeout 10s python $script_name 4 2>&1
  echo $?
#+end_src

#+RESULTS:
: 124

Ok, so what I did is just too damn slow even for our limited constraints. Perhaps we can try to speed it up. I'm not ready to blame this all on Pandas just yet
