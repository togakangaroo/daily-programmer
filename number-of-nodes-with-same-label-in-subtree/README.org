#+TITLE: Number of Nodes in the Sub-Tree With the Same Label

* Problem Statement
- [[https://operation-code.slack.com/archives/C7JMZ5LAV/p1673533729987749][From the Operation Code Slack]]

You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of ~n~ nodes numbered from ~0~ to ~n - 1~ and exactly ~n - 1~ edges. The root of the tree is the node ~0~, and each node of the tree has a label which is a lower-case character given in the string labels (i.e. The node with the number ~i~ has the label ~labels[i]~).

The edges array is given on the form ~edges[i] = [ai, bi]~, which means there is an edge between nodes ~ai~ and ~bi~ in the tree.

Return an array of size ~n~ where ~ans[i]~ is the number of nodes in the subtree of the ~ith~ node which have the same label as node ~i~.

A subtree of a tree ~T~ is the tree consisting of a node in ~T~ and all of its descendant nodes.
** Exmaple 1

#+DOWNLOADED: screenshot @ 2023-01-13 21:15:43
[[file:Problem_Statement/2023-01-13_21-15-43_screenshot.png]]


| n | edges                                 | labels  | output          |
|---+---------------------------------------+---------+-----------------|
| 7 | ((0 1) (0 2) (1 4) (1 5) (2 3) (2 6)) | abaedcd | (2 1 1 1 1 1 1) |

*Explanation:* =Node 0= has =label 'a'= and its sub-tree has =node 2= with =label 'a'= as well, thus the answer is =2=. Notice that any node is part of its sub-tree. =Node 1= has a =label 'b'=. The sub-tree of =node 1= contains =nodes 1,4= and =5=, as =nodes 4 and 5= have different labels than =node 1=, the answer is just =1= (the node itself).
** Example 2

#+DOWNLOADED: screenshot @ 2023-01-13 21:20:49
[[file:Problem_Statement/2023-01-13_21-20-49_screenshot.png]]

| n | edges               | labels | output     |
|---+---------------------+--------+------------|
| 4 | ((0 1) (1 2) (0 3)) | bbbb   | (4 2 1 1 ) |

** Example 3

#+DOWNLOADED: screenshot @ 2023-01-13 21:24:50
[[file:Problem_Statement/2023-01-13_21-24-50_screenshot.png]]

| n | edges                     | labels | output      |
|---+---------------------------+--------+-------------|
| 5 | ((0 1) (0 2) (1 3) (0 4)) | aabab  | (3 2 1 1 1) |

** Constraints
- ~1 <= n <= 105~
- ~ai~=bi~
- ~labels~ is consisting of only of lowercase English letters.

* Brainstorming

First it occurs to me that ~n~ is completely ancillary. Specifically, it *must* be true that ~n = length(edges)+1 = length(labels)~ for any of this to be valid. This was originally written into the constraints which I didn't bother copying but its worth pointing out that not only is it a constraint but the problem literally makes no sense if this is not true.

Next there's the point that ~n <= 105~. This isn't like a super-deep tree, while I *want* to do better than brute-force here, realistically brute-force would be just fine.

Another thought bubble is that the number of duplicates in ~labels~ set upper bounds. In [[Example 3]] we have ~labels="aabab"~. That means a node associated with ~a~ can only have =3, 2, or 1= count and in fact *some* node associated with ~a~ must have a =1= count (maybe even two nodes). At the very least it is useful in the following situation: Consider a tree as follows

#+begin_src plantuml :file Problem_Statement/brainstorming-diagram.png
  @startuml
  hide empty description
  [*] -> a0
  a0 -> a1
  a0 --> b2
  a1 -> b3
  b3 -> b4
  b2 -> c5
#+end_src

#+RESULTS:
[[file:Problem_Statement/brainstorming-diagram.png]]

If you are trying to get the same-label factor for =a0= you need only to take one step. This gives you the factor =2= and since you know it is impossible for there to be more than two =a= nodes, you can stop navigating the subtree.

In fact, as the above example shows, this will *also* tell you the factor for =a1=. And once we've established the factor for a node, it might as well not exist. After we've preformed the above navigation, we might as well be working with two disconnected trees. Nodes =a0= and =a1= can no longer affect any output since nothing beneath them can possibly be an =a=

#+begin_src plantuml :file Problem_Statement/brainstorming-diagram2.png
  @startuml
  hide empty description
  [*] -> b3
  [*] --> b2
  b3 -> b4
  b2 -> c5
#+end_src

#+RESULTS:
[[file:Problem_Statement/brainstorming-diagram2.png]]

One more thought is that while the last contraint about labels being only english letters might feel meaningless, it actually sets an upper bound for how many different labels we might have; 26. This means that grouping by node label and then jumping around from there might not be such a bad tactical move, we just aren't going to have that much stuff to go through.

Finally, there's the interesting setup of our connections. The first item is where we're jumping from, the next where we're jumping to. You can navigate an entire subtree pretty easily this way and if we're going to be doing that a lot, sticking them into a hashtree by the first element might be a great idea up front.
