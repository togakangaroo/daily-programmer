#+TITLE: Number of Nodes in the Sub-Tree With the Same Label

* Problem Statement
- [[https://operation-code.slack.com/archives/C7JMZ5LAV/p1673533729987749][From the Operation Code Slack]]

You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of ~n~ nodes numbered from ~0~ to ~n - 1~ and exactly ~n - 1~ edges. The root of the tree is the node ~0~, and each node of the tree has a label which is a lower-case character given in the string labels (i.e. The node with the number ~i~ has the label ~labels[i]~).

The edges array is given on the form ~edges[i] = [ai, bi]~, which means there is an edge between nodes ~ai~ and ~bi~ in the tree.

Return an array of size ~n~ where ~ans[i]~ is the number of nodes in the subtree of the ~ith~ node which have the same label as node ~i~.

A subtree of a tree ~T~ is the tree consisting of a node in ~T~ and all of its descendant nodes.
** Exmaple 1

#+DOWNLOADED: screenshot @ 2023-01-13 21:15:43
[[file:Problem_Statement/2023-01-13_21-15-43_screenshot.png]]


| n | edges                                 | labels  | output          |
|---+---------------------------------------+---------+-----------------|
| 7 | ((0 1) (0 2) (1 4) (1 5) (2 3) (2 6)) | abaedcd | (2 1 1 1 1 1 1) |

*Explanation:* =Node 0= has =label 'a'= and its sub-tree has =node 2= with =label 'a'= as well, thus the answer is =2=. Notice that any node is part of its sub-tree. =Node 1= has a =label 'b'=. The sub-tree of =node 1= contains =nodes 1,4= and =5=, as =nodes 4 and 5= have different labels than =node 1=, the answer is just =1= (the node itself).
** Example 2

#+DOWNLOADED: screenshot @ 2023-01-13 21:20:49
[[file:Problem_Statement/2023-01-13_21-20-49_screenshot.png]]

| n | edges               | labels | output     |
|---+---------------------+--------+------------|
| 4 | ((0 1) (1 2) (0 3)) | bbbb   | (4 2 1 1 ) |

** Example 3

#+DOWNLOADED: screenshot @ 2023-01-13 21:24:50
[[file:Problem_Statement/2023-01-13_21-24-50_screenshot.png]]

| n | edges                     | labels | output      |
|---+---------------------------+--------+-------------|
| 5 | ((0 1) (0 2) (1 3) (0 4)) | aabab  | (3 2 1 1 1) |

** Constraints
- ~1 <= n <= 105~
- ~ai~=bi~
- ~labels~ is consisting of only of lowercase English letters.

* Brainstorming

First it occurs to me that ~n~ is completely ancillary. Specifically, it *must* be true that ~n = length(edges)+1 = length(labels)~ for any of this to be valid. This was originally written into the constraints which I didn't bother copying but its worth pointing out that not only is it a constraint but the problem literally makes no sense if this is not true.

Next there's the point that ~n <= 105~. This isn't like a super-deep tree, while I *want* to do better than brute-force here, realistically brute-force would be just fine.

Another thought bubble is that the number of duplicates in ~labels~ set upper bounds. In [[Example 3]] we have ~labels="aabab"~. That means a node associated with ~a~ can only have =3, 2, or 1= count and in fact *some* node associated with ~a~ must have a =1= count (maybe even two nodes). At the very least it is useful in the following situation: Consider a tree as follows

#+begin_src plantuml :file Problem_Statement/brainstorming-diagram.png
  @startuml
  hide empty description
  [*] -> a0
  a0 -> a1
  a0 --> b2
  a1 -> b3
  b3 -> b4
  b2 -> c5
#+end_src

#+RESULTS:
[[file:Problem_Statement/brainstorming-diagram.png]]

If you are trying to get the same-label factor for =a0= you need only to take one step. This gives you the factor =2= and since you know it is impossible for there to be more than two =a= nodes, you can stop navigating the subtree.

In fact, as the above example shows, this will *also* tell you the factor for =a1=. And once we've established the factor for a node, it might as well not exist. After we've preformed the above navigation, we might as well be working with two disconnected trees. Nodes =a0= and =a1= can no longer affect any output since nothing beneath them can possibly be an =a=

#+begin_src plantuml :file Problem_Statement/brainstorming-diagram2.png
  @startuml
  hide empty description
  [*] -> b3
  [*] --> b2
  b3 -> b4
  b2 -> c5
#+end_src

#+RESULTS:
[[file:Problem_Statement/brainstorming-diagram2.png]]

One more thought is that while the last contraint about labels being only english letters might feel meaningless, it actually sets an upper bound for how many different labels we might have; 26. This means that grouping by node label and then jumping around from there might not be such a bad tactical move, we just aren't going to have that much stuff to go through.

Finally, there's the interesting setup of our connections. The first item is where we're jumping from, the next where we're jumping to. You can navigate an entire subtree pretty easily this way and if we're going to be doing that a lot, sticking them into a hashtree by the first element might be a great idea up front.

So interestingly, I feel like this problem is actually a good fit for mutability and object orientation. For example in the above, if ~a1~ is a mutable node it can be done in a way where you can implment visitor pattern such that when you call ~a1.visit(fn)~ it will apply ~fn(a1)~ before delegating to children until its factor is known, and will immediately delegate to children once it is. I like this idea.

* Implementations
:PROPERTIES:
:header-args: :noweb yes
:header-args:typescript: :eval no
:END:

I feel like I haven't done these in Typescript, let's do that. While I'm sure brute-force is perfectly good enough, I think some of the optimizations would be fun here.

First we're going to need to count up the numbers of individual labels in the ~labels~ string so we can use these for the upper-bound optimization

#+name: getLabelCounts
#+begin_src typescript
  const getLabelCounts = (labels: string) => {
      const counts = new Map<string, number>()
      for(const c of labels)
          counts.set(c, 1 + (counts.get(c) ?? 0))
      return counts
  }
#+end_src

#+begin_src typescript :eval yes
  <<getLabelCounts>>
  console.log(getLabelCounts("bacbab"))
#+end_src

#+RESULTS:
: Map(3) { 'b' => 3, 'a' => 2, 'c' => 1 }

That works well.

Next, lets create a structure for our ~Node~. As described above this would have a mutable ~subtreeLabelFactor~ and a mutable ~visit~ function. Note that I really dislike using ~this~ in javascript so I'm just going to use the python convention for now. Maybe I'll reform this as a class at some point

#+name: Node
#+begin_src typescript :eval yes :results silent
  type Node = {
      readonly children: Node[]
      readonly label: NonNullable<string>
      readonly index: NonNullable<number>
      visit: (self: Node, fn: (item: Node) => void) => void
      subtreeLabelFactor: number | null
  }
#+end_src

Now lets write a node constructor funciton. Yes, I could do classes, but I don't love them as a primitive. Given the choice, I'd prefer to use basic types and factory functions, and while that's not the most idiomatic thing in Typescript, its also not so uncommon a pattern that a mob will be showing up at might front door for doing this.

Note that we don't actually know *which* node will be the "root node" of our tree and we'll likely need ease-of-access so we'll hash every single node by index so that it can be easily jumped to.

#+name: createTree
#+begin_src typescript
  const visitChildren: Node["visit"] = (self, fn) => {
      for(const c of self.children)
          c.visit(c, fn)
  }

  const visitSelf: Node["visit"] = (self, fn) => {
      fn(self)
      visitChildren(self, fn)
  }


  const createTree = (labels: string, edges: Array<[number, number]>) => {
      const nodes = new Map<number, Node>()

      const getNode = (index: number) : Node => {
          let node = nodes.get(index)
          if(!node) {
              node = {
                  index,
                  label: labels[index],
                  children: [],
                  visit: visitSelf,
                  subtreeLabelFactor: null,
              }
              nodes.set(index, node)
          }
          return node
      }

      for(const [fromIndex, toIndex] of edges)
          getNode(fromIndex).children.push(getNode(toIndex))

      return nodes
  }
#+end_src

#+begin_src typescript :eval yes
  const labels = "aabbbc"
  const edges : Array<[number, number]> = [[0, 1], [1, 3], [3, 4], [0, 2], [2, 5]]

  <<Node>>
  <<createTree>>
  const tree = createTree("abcd", [[0,1], [0, 2], [1, 3]])
  console.log(tree)
#+end_src

#+RESULTS:
#+begin_example
Map(4) {
  0 => {
    index: 0,
    label: 'a',
    children: [ [Object], [Object] ],
    visit: [Function: visitSelf],
    subtreeLabelFactor: null
  },
  1 => {
    index: 1,
    label: 'b',
    children: [ [Object] ],
    visit: [Function: visitSelf],
    subtreeLabelFactor: null
  },
  2 => {
    index: 2,
    label: 'c',
    children: [],
    visit: [Function: visitSelf],
    subtreeLabelFactor: null
  },
  3 => {
    index: 3,
    label: 'd',
    children: [],
    visit: [Function: visitSelf],
    subtreeLabelFactor: null
  }
}
#+end_example

That seems good!

That's cool and that feels badass but it also feels like we're overcomplicating stuff. There's multiple passes through the lists and in fact when it comes to how to implement ~visit~...I'm sure I'm going to have to change some stuff since we'd be passing through the current label.

#+begin_src typescript :eval yes
  const labels = "aabbbc"
  const edges : Array<[number, number]> = [[0, 1], [1, 3], [3, 4], [0, 2], [2, 5]]
#+end_src
