#+TITLE: Number of Nodes in the Sub-Tree With the Same Label

* Problem Statement
- [[https://operation-code.slack.com/archives/C7JMZ5LAV/p1673533729987749][From the Operation Code Slack]]

You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of ~n~ nodes numbered from ~0~ to ~n - 1~ and exactly ~n - 1~ edges. The root of the tree is the node ~0~, and each node of the tree has a label which is a lower-case character given in the string labels (i.e. The node with the number ~i~ has the label ~labels[i]~).

The edges array is given on the form ~edges[i] = [ai, bi]~, which means there is an edge between nodes ~ai~ and ~bi~ in the tree.

Return an array of size ~n~ where ~ans[i]~ is the number of nodes in the subtree of the ~ith~ node which have the same label as node ~i~.

A subtree of a tree ~T~ is the tree consisting of a node in ~T~ and all of its descendant nodes.
** Exmaple 1

#+DOWNLOADED: screenshot @ 2023-01-13 21:15:43
[[file:Problem_Statement/2023-01-13_21-15-43_screenshot.png]]


| n | edges                                 | labels  | output          |
|---+---------------------------------------+---------+-----------------|
| 7 | ((0 1) (0 2) (1 4) (1 5) (2 3) (2 6)) | abaedcd | (2 1 1 1 1 1 1) |

*Explanation:* =Node 0= has =label 'a'= and its sub-tree has =node 2= with =label 'a'= as well, thus the answer is =2=. Notice that any node is part of its sub-tree. =Node 1= has a =label 'b'=. The sub-tree of =node 1= contains =nodes 1,4= and =5=, as =nodes 4 and 5= have different labels than =node 1=, the answer is just =1= (the node itself).
** Example 2

#+DOWNLOADED: screenshot @ 2023-01-13 21:20:49
[[file:Problem_Statement/2023-01-13_21-20-49_screenshot.png]]

| n | edges               | labels | output     |
|---+---------------------+--------+------------|
| 4 | ((0 1) (1 2) (0 3)) | bbbb   | (4 2 1 1 ) |

** Example 3

#+DOWNLOADED: screenshot @ 2023-01-13 21:24:50
[[file:Problem_Statement/2023-01-13_21-24-50_screenshot.png]]

| n | edges                     | labels | output      |
|---+---------------------------+--------+-------------|
| 5 | ((0 1) (0 2) (1 3) (0 4)) | aabab  | (3 2 1 1 1) |

** Constraints
- ~1 <= n <= 105~
- ~ai~=bi~
- ~labels~ is consisting of only of lowercase English letters.

* Brainstorming

First it occurs to me that ~n~ is completely ancillary. Specifically, it *must* be true that ~n = length(edges)+1 = length(labels)~ for any of this to be valid. This was originally written into the constraints which I didn't bother copying but its worth pointing out that not only is it a constraint but the problem literally makes no sense if this is not true.

Next there's the point that ~n <= 105~. This isn't like a super-deep tree, while I *want* to do better than brute-force here, realistically brute-force would be just fine.

Another thought bubble is that the number of duplicates in ~labels~ set upper bounds. In [[Example 3]] we have ~labels="aabab"~. That means a node associated with ~a~ can only have =3, 2, or 1= count and in fact *some* node associated with ~a~ must have a =1= count (maybe even two nodes). I am not sure if this information is useful but it has a certain useful-feel to it.
