* Sort the Matrix Diagonally
** The Problem
   Given a ~m * n~ matrix ~mat~ of integers, sort it diagonally in ascending order from the top-left to the bottom-right then return the sorted array.

   #+name: example-1-input
   | 3 | 3 | 1 | 1 |
   | 2 | 2 | 1 | 2 |
   | 1 | 1 | 1 | 2 |



   #+name: example-1-output
   | 1 | 1 | 1 | 1 |
   | 1 | 2 | 2 | 2 |
   | 1 | 2 | 3 | 3 |

   | 1 | 1 | 1 | 1 |
   | 1 | 3 | 2 | 2 |
   | 1 | 3 | 3 | 3 |

   | 1 | 1 | 1 | 2 |
   | 1 | 2 | 2 | 2 |
   | 2 | 2 | 3 | 3 |

   Constraints:

   #+begin_quote
   m == mat.length
   n == mat[i].length
   1 <= m, n <= 100
   1 <= mat[i][j] <= 100
   #+end_quote

** Implementation

   The problem statement is actually a little limited in the information it gives. It does not specify exactly *what* diagonal order is. Yes, each diagonal should be sorted, but there's multiple ways to do that.

   So we get to choose. And the most straightforward way I can think of of doing that is to define an order where you start by filling in the top row and leftmost column in alternating order, moving inward as necessary, you should always end up with

   In other words, if we are filling a =3x5= matrix from a list of numbers 0-14 we would end up with the following.

   | 0 | 1 |  3 |  5 |  6 |
   | 2 | 7 |  8 | 10 | 11 |
   | 4 | 9 | 12 | 13 | 14 |

   We would therefore expect the following output

   | Row | Column |
   |-----+--------|
   |   0 |      0 |
   |   0 |      1 |
   |   1 |      0 |
   |   0 |      2 |
   |   2 |      0 |
   |   0 |      3 |
   |   0 |      4 |
   |   1 |      1 |
   |   1 |      2 |
   |   2 |      1 |
   |   1 |      3 |
   |   1 |      4 |
   |   2 |      2 |
   |   2 |      3 |
   |   2 |      4 |


   #+name: matrix-diagonal-cells
   #+begin_src racket :exports both :eval o
     (require racket/generator)
     (require sfont/geometry)

     (define (values-get fn) (lambda args (fn args)))
     (define (matrix-diagonal-cells row-count column-count)
       (in-generator
        (let recurse ([add-in (vec 0 0)]
                      [dimensions (vec row-count column-count)])
          (define (yield-vec v) (yield (vec+ v add-in)))
          (define (get-dimension fn) (apply fn (vec->list dimensions)) )
          (define overflow-direction (if (> (get-dimension (values-get first)) (get-dimension (values-get second)))
                                         (vec 1 0)
                                         (vec 0 1)))
          (when (< 0 (apply min (vec->list dimensions)))
            (yield-vec (vec 0 0))
            (for ([i (range 1 (get-dimension min))])
              (yield-vec (vec 0 i))
              (yield-vec (vec i 0)))
            (for ([i (range (get-dimension min) (get-dimension max))])
              (yield-vec (vec* overflow-direction i)))
            (recurse (vec+ add-in (vec 1 1)) (vec- dimensions (vec 1 1)))))))
   #+end_src

   #+begin_src racket :exports both :results output :noweb strip-export :var data=example-1-input
     <<matrix-diagonal-cells>>
     (sequence->list (matrix-diagonal-cells 3 5))
   #+end_src

   #+RESULTS:
   : (list (vec 0 0) (vec 0 1) (vec 1 0) (vec 0 2) (vec 2 0) (vec 0 3) (vec 0 4) (vec 1 1) (vec 1 2) (vec 2 1) (vec 1 3) (vec 1 4) (vec 2 2) (vec 2 3) (vec 2 4))

   This looks good, so now we would only need to join, sort, and populate a matrix according to this sequence
   
   #+begin_src racket :exports both :results output :noweb strip-export :var data=example-1-input
     (require threading)
      (require (except-in data/collection sequence->list)) ;;https://stackoverflow.com/a/62505165/5056
     <<matrix-diagonal-cells>>
     (~> data
         (apply in-sequences _)
         sequence->list
         (sort <))
   #+end_src

   #+RESULTS:
   : '(1 1 1 1 1 1 2 2 2 2 3 3)

** Playground

   #+begin_src racket :exports both :results output table :var data=example-1-input
     (require csv-writing)
     (display-table data)
     (list (length (first data)) (length data))

   #+end_src

   #+RESULTS:
   : 3,3,1,1
   : 2,2,1,2
   : 1,1,1,2
   : '(4 3)

   #+begin_src racket :exports both :results output
     (require racket/match)
     (require threading)
     (require sfont/geometry)
     (define (values-get fn) (lambda args (fn args)))
     ((values-get second) 1 2 3 4)
   #+end_src

   #+RESULTS:
   : 2
