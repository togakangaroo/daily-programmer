#+title: Reverse Substrings Between Each Pair of Parentheses
* Reverse Substrings Between Each Pair of Parentheses
** Problem

   You are given a string ~s~ that consists of lower case English letters and brackets. Reverse the strings in each pair of matching parentheses, starting from the innermost one. Your result should not contain any brackets.

   Input: ~s = "(abcd)"~
   Output: ~"dcba"~

   Input: ~s = "(u(love)i)"~
   Output: ~"iloveu"~
   Explanation: The substring “love” is reversed first, then the whole string is reversed.

   Input: s =

   #+name: example-input-1
   a(bcdefghijkl(mno)p)q

   Output: ~"apmnolkjihgfedcbq"~

   Constraints:
   - 0 <= s.length <= 2000
   - s only contains lower case English characters and parentheses.
   - It is guaranteed that all parentheses are balanced

*** Ideation

    The fact that I want to do this in Racket (a LISP focused on building your own language) could give me an edge.

    What if this example ~a(bcdefghijkl(mno)p)q~ could be converted to

    #+begin_src racket :eval no
      (string-append "a" (reverse-contents "bcdefghijkl" (reverse-contents "mno") "p") "q")

      ;;=> (string-append "a" (reverse-contents "bcdefghijkl" "onm" "p") "q")
      ;;=> (string-append "a" "pmnolkjihgfedcb" "q")
      ;;=> "apmnolkjihgfedcbq"
    #+end_src

    where ~reverse-contents~ takes a list of strings, reverses each, reverses the list itself, then appends the results together into a single string
    
    #+begin_src racket 
      (require (for-syntax racket/match))
      (require threading)

      (define reverse-string (lambda~> string->list reverse list->string))

      (define (reverse-contents . strs)
        (reverse (map reverse-string strs)))

      (string-append* (reverse-contents "abcdefg" "hijk" "l"))
    #+end_src

    #+RESULTS:
    : "lkjihgfedcba"

    Looks like that would work
   
***  Language

