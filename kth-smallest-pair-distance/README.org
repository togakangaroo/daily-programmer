#+OPTIONS: toc:nil
#+OPTIONS: html-postamble:nil

* Problem Statement

The distance of a pair of integers a and b is defined as the absolute difference between a and b.

Given an integer array nums and an integer =k=, return the kth smallest distance among all the pairs =nums[i]= and =nums[j]= where ~0 <= i < j < nums.length~

** Example 1:

- Input :: ~nums = [1,3,1], k = 1~
- Output :: ~0~
- Explanation :: Here are all the pairs:
  - =(1,3) -> 2=
  - =(1,1) -> 0=
  - =(3,1) -> 2=

Then the 1st smallest distance pair is =(1,1)=, and its distance is =0=.

** Example 2:

- Input :: ~nums = [1,1,1], k = 2~
- Output :: ~0~

** Example 3:

- Input :: ~nums = [1,6,1], k = 3~
- Output :: ~5~
- Explanation :: Here are all the pairs:
  - =(1,6) -> 5=
  - =(1,1) -> 0=
  - =(6,1) -> 5=

** Constraints:

- ~n == nums.length~
- ~2 <= n <= 10^4~
- ~0 <= nums[i] <= 10^6~
- ~1 <= k <= n * (n - 1) / 2~

* Brainstorming

Well, we can of course brute force it, write out all the pairs. That's O(n^2). Something like that?


But hold on, it occurs to me that if we sort the list, then its relatively trivial to find the kth item. In fact, do we even need to sort the list? If its a big list and I want the 2nd smallest difference for example, I only have to know the order of the medium-est numbers, not the extremes. Hmm, how easy it is to know the "middlest"? Do you have to sort for that or is there another way to get it?

 1 4 2 4
 4,4 -> 0
 1,2 -> 1
 4,2 -> 2
 2,4 -> 2
 1,4 -> 3
 1,4 -> 3

 You know what...lets talk about the range of optimizations

 So let's say ~k = 2~, Then
 - if you have more than 3 of any two numbers, stop counting, you're done. The answer will be ~0~
 - if you have even 100 of numbers that are 1 apart, it doesn't matter, you can't say anything
   - unless you have only 1 number ~(n-k)~ left to look at
