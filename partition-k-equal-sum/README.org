#+TITLE: Partition to K Equal Sum Subsets

* Problem Statement
  
  Given an integer array ~nums~ and an integer ~k~, return ~true~ if it is possible to divide this array into k non-empty subsets whose sums are all equal.
  
** Example 1:
   * Input :: ~nums = [4,3,2,3,5,2,1], k = 4~
   * Output :: ~true~
   * Explanation :: It's possible to divide it into 4 subsets ~(5), (1, 4), (2,3), (2,3)~ with equal sums.

** Example 2:
   * Input :: ~nums = [1,2,3,4], k = 3~
   * Output :: ~false~

** Constraints
   - ~1 <= k <= nums.length <= 16~
   - ~1 <= nums[i] <= 104~
   - The frequency of each element is in the range ~[1, 4]~.

* Brainstorm

  So the numbers on this aren't so high. Instinctively I should be able to just depth-first-search through ~nums~ with some basic optimizations 

**  Brute force DFS

   So lets start with an example. How about that first one?

   ~nums = [4,3,2,3,5,2,1], k = 3~

   The different ways to draw 4 elements from this set is
   
#+begin_src racket
  (require threading)
  
  (~> '(4 3 2 3 5 2 1)
      (in-combinations 3)
      sequence->list)
#+end_src

#+RESULTS:
: '((4 3 2) (4 3 3) (4 3 5) (4 3 2) (4 3 1) (4 2 3) (4 2 5) (4 2 2) (4 2 1) (4 3 5) (4 3 2) (4 3 1) (4 5 2) (4 5 1) (4 2 1) (3 2 3) (3 2 5) (3 2 2) (3 2 1) (3 3 5) (3 3 2) (3 3 1) (3 5 2) (3 5 1) (3 2 1) (2 3 5) (2 3 2) (2 3 1) (2 5 2) (2 5 1) (2 2 1) (3 5 2) (3 5 1) (3 2 1) (5 2 1))

For each of these we can consider all combinations of the remainder So take the first one ~(4 3 2)~ and the remainder is

#+begin_src racket
  (require threading)
  (~> '(3 5 2 1)
      (in-combinations 3)
      sequence->list)
#+end_src

#+RESULTS:
: '((3 5 2) (3 5 1) (3 2 1) (5 2 1))
